---
articleID: 15107
---

import {getPlatformData} from "/snippets/utils-content-parser.js"

export const ZIMMessageSendConfigMap = {
  'Android': <a href='@-ZIMMessageSendConfig' target='_blank'>ZIMMessageSendConfig</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMMessageSendConfig-class.html' target='_blank'>ZIMMessageSendConfig</a>,
}
export const sendMessageMap = {
  'Android': <a href='@sendMessage' target='_blank'>sendMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/sendMessage.html' target='_blank'>sendMessage</a>,
}
export const sendMediaMessageMap = {
  'Android': <a href='@sendMediaMessage' target='_blank'>sendMediaMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/sendMediaMessage.html' target='_blank'>sendMediaMessage</a>,
}
export const onReceivePeerMessageMap = {
  'Android': <a href='@onReceivePeerMessage' target='_blank'>onReceivePeerMessage</a>,
  'Web': <a href='@receivePeerMessage' target='_blank'>receivePeerMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onReceivePeerMessage.html' target='_blank'>onReceivePeerMessage</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
}
export const onReceiveGroupMessageMap = {
  'Android': <a href='@onReceiveGroupMessage' target='_blank'>onReceiveGroupMessage</a>,
  'Web': <a href='@receiveGroupMessage' target='_blank'>receiveGroupMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onReceiveGroupMessage.html' target='_blank'>onReceiveGroupMessage</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-group-message-from-group-id' target='_blank'>receiveGroupMessage</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-group-message-from-group-id' target='_blank'>receiveGroupMessage</a>,
}
export const sendMessageReceiptsReadMap = {
  'Android': <a href='@sendMessageReceiptsRead' target='_blank'>sendMessageReceiptsRead</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/sendMessageReceiptsRead.html' target='_blank'>sendMessageReceiptsRead</a>,
}
export const ZIMMessageReceiptsReadSentCallbackMap = {
  'Android': <a href='@-ZIMMessageReceiptsReadSentCallback' target='_blank'>ZIMMessageReceiptsReadSentCallback</a>,
  'Web': <a href='@-ZIMMessageReceiptsReadSentResult' target='_blank'>ZIMMessageReceiptsReadSentResult</a>,
  'U3d': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~cs_unity3d~interface~ZIMDefines#zim-message-receipts-read-sent-callback' target='_blank'>ZIMMessageReceiptsReadSentCallback</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMMessageReceiptsReadSentResult-class.html' target='_blank'>ZIMMessageReceiptsReadSentCallback</a>,
  'iOS,mac,window': <a href='@ZIMMessageReceiptsReadSentCallback' target='_blank'>ZIMMessageReceiptsReadSentCallback</a>,
}
export const onMessageReceiptChangedMap = {
  'Android': <a href='@onMessageReceiptChanged' target='_blank'>onMessageReceiptChanged</a>,
  'Web': <a href='@messageReceiptChanged' target='_blank'>messageReceiptChanged</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onMessageReceiptChanged.html' target='_blank'>onMessageReceiptChanged</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-message-receipt-changed' target='_blank'>messageReceiptChanged</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-message-receipt-changed' target='_blank'>messageReceiptChanged</a>,
}
export const ZIMEventHandlerMap = {
  'Android': <a href='@-ZIMEventHandler' target='_blank'>ZIMEventHandler</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler-class.html' target='_blank'>ZIMEventHandler</a>,
}
export const sendConversationMessageReceiptReadMap = {
  'Android': <a href='@sendConversationMessageReceiptRead' target='_blank'>sendConversationMessageReceiptRead</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/sendConversationMessageReceiptRead.html' target='_blank'>sendConversationMessageReceiptRead</a>,
}
export const ZIMConversationMessageReceiptReadSentCallbackMap = {
  'Android': <a href='@-ZIMConversationMessageReceiptReadSentCallback' target='_blank'>ZIMConversationMessageReceiptReadSentCallback</a>,
  'Web': <a href='@-ZIMConversationMessageReceiptReadSentResult' target='_blank'>ZIMConversationMessageReceiptReadSentResult</a>,
  'U3d': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~cs_unity3d~interface~ZIMDefines#zim-conversation-message-receipt-read-sent-callback' target='_blank'>ZIMConversationMessageReceiptReadSentCallback</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMConversationMessageReceiptReadSentResult-class.html' target='_blank'>ZIMConversationMessageReceiptReadSentResult</a>,
  'iOS,mac,window': <a href='@ZIMConversationMessageReceiptReadSentCallback' target='_blank'>ZIMConversationMessageReceiptReadSentCallback</a>,
}
export const onConversationMessageReceiptChangedMap = {
  'Android': <a href='@onConversationMessageReceiptChanged' target='_blank'>onConversationMessageReceiptChanged</a>,
  'Web': <a href='@conversationMessageReceiptChanged' target='_blank'>conversationMessageReceiptChanged</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onConversationMessageReceiptChanged.html' target='_blank'>onConversationMessageReceiptChanged</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-conversation-message-receipt-changed' target='_blank'>conversationMessageReceiptChanged</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-conversation-message-receipt-changed' target='_blank'>conversationMessageReceiptChanged</a>,
}
export const queryMessageReceiptsInfoMap = {
  'Android': <a href='@queryMessageReceiptsInfo' target='_blank'>queryMessageReceiptsInfo</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/queryMessageReceiptsInfo.html' target='_blank'>queryMessageReceiptsInfo</a>,
  'iOS,mac': <a href='@queryMessageReceiptsInfoByMessageList' target='_blank'>queryMessageReceiptsInfoByMessageList</a>,
}
export const ZIMMessageReceiptsInfoQueriedCallbackMap = {
  'Android': <a href='@-ZIMMessageReceiptsInfoQueriedCallback' target='_blank'>ZIMMessageReceiptsInfoQueriedCallback</a>,
  'Web': <a href='@-ZIMMessageReceiptsInfoQueriedResult' target='_blank'>ZIMMessageReceiptsInfoQueriedResult</a>,
  'U3d': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~cs_unity3d~interface~ZIMDefines#zim-message-receipts-info-queried-callback' target='_blank'>ZIMMessageReceiptsInfoQueriedCallback</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMMessageReceiptsInfoQueriedResult-class.html' target='_blank'>ZIMMessageReceiptsInfoQueriedResult</a>,
  'iOS,mac,window': <a href='@ZIMMessageReceiptsInfoQueriedCallback' target='_blank'>ZIMMessageReceiptsInfoQueriedCallback</a>,
}
export const queryGroupMessageReceiptReadMemberListMap = {
  'Android': <a href='@queryGroupMessageReceiptReadMemberList' target='_blank'>queryGroupMessageReceiptReadMemberList</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/queryGroupMessageReceiptUnreadMemberList.html' target='_blank'>queryGroupMessageReceiptReadMemberList</a>,
  'iOS,mac': <a href='@queryGroupMessageReceiptReadMemberListByMessage' target='_blank'>queryGroupMessageReceiptReadMemberListByMessage</a>,
}
export const queryGroupMessageReceiptUnreadMemberListMap = {
  'Android': <a href='@queryGroupMessageReceiptUnreadMemberList' target='_blank'>queryGroupMessageReceiptUnreadMemberList</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/queryGroupMessageReceiptReadMemberList.html' target='_blank'>queryGroupMessageReceiptUnreadMemberList</a>,
  'iOS,mac': <a href='@queryGroupMessageReceiptUnreadMemberListByMessage' target='_blank'>queryGroupMessageReceiptUnreadMemberListByMessage</a>,
}


# Read receipts
- - -

:::if{props.platform="U3d"}
<Note title="Note">

This document is applicable to the following platforms of Unity framework: iOS, Android, macOS, and Windows.
</Note>
:::

## Overview

Message reading receipt helps users know whether other users have read the messages they sent in a session. This feature applies to enterprise office businesses and other scenarios in which the message reading status needs to be known in real time.

This document describes how to use APIs of the In-app Chat SDK to send messages that require a reading receipt, query the receipt status of messages, and set messages as read.

<Warning title="Warning">

The In-app Chat SDK supports reading receipts for one-to-one messages and group messages (only common messages and rich media messages) and does not support reading receipts for in-room messages.

</Warning>

## Prerequisites

Before you implement the `message reading receipt` feature, ensure that the following conditions are met:

- **Create a project** in [ZEGOCLOUD Console](https://console.zegocloud.com). The ZIM service permission is not enabled by default. Before using it, please activate the ZIM service by yourself in [ZEGOCLOUD Console](https://console.zegocloud.com) (for details, please refer to [Project Management - In-app Chat ](#15174)), if you cannot activate the ZIM service, please contact ZEGOCLOUD technical support to activate it.
- Integrate the ZIM SDK. For details, see the **Integrate the SDK** chapter of [Send and receive messages](!Implementation_of_sending_and_receiving).

## Implementation process

The sender sends a message through the In-app Chat SDK and sets the `hasReceipt` field of {getPlatformData(props,ZIMMessageSendConfigMap)} to identify whether a reading receipt is required for the message. Based on the `receiptStatus` field, the receiver determines whether a reading receipt is required for the message or whether the message is read or unread to render different UI effects. The message receiver can use different reading methods based on the scenario.

### Send a message that requires a reading receipt

When Client A wants to send a message that requires a reading receipt to Client B:
1. Client A and Client B log in to the In-app Chat service.
2. Client A calls the {getPlatformData(props,sendMessageMap)} or {getPlatformData(props,sendMediaMessageMap)} API to send a message (common message or rich media message in one-to-one or group chats) to Client B and sets the `hasReceipt` field of {getPlatformData(props,ZIMMessageSendConfigMap)} to **true**.
3. By listening for related callback ({getPlatformData(props,onReceivePeerMessageMap)} or {getPlatformData(props,onReceiveGroupMessageMap)}), Client B receives a message whose `receiptStatus` is set to `PROCESSING`.

### Set the reading receipt status as read

In this operation, `set a message as read` and `set a session as read` are both supported.

#### Set a message as read

The receiver can set a message that requires a reading receipt from the sender as read. Then, the sender will receive a message read notification.

<Warning title="Warning">

- A single message or a batch of messages are supported. The sender and receiver must be in the same session. Cross-session operations are not supported.
  
- To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](!query_Message_Records).
</Warning>

1. Through related callback ({getPlatformData(props,onReceivePeerMessageMap)} or {getPlatformData(props,onReceiveGroupMessageMap)}), Client B receives a message that requires a reading receipt from Client A.
2. Based on the `receiptStatus` field of the callback, Client B determines the receipt status of the message. If this field is set to `PROCESSING`, the message is unread. Developers can call the {getPlatformData(props,sendMessageReceiptsReadMap)} API to set the message as read based on the service logic.
3. Client B determines whether the setting is successful based on {getPlatformData(props,ZIMMessageReceiptsReadSentCallbackMap)}.
4. Based on {getPlatformData(props,onMessageReceiptChangedMap)} of {getPlatformData(props,ZIMEventHandlerMap)}, Client A receives a callback notification, indicating that the message is set as read. Developers can implement the service logic of setting the message as read on Client A based on this callback.


#### Set a session as read

The receiver can set all messages **received** from the sender in a specified session as read.

<Warning title="Warning">

- The In-app Chat SDK supports this feature only in **one-to-one chats**.  
- This feature takes effect only on messages received before setting the feature. 
- It is recommended that this feature be used when a user switches from the session list page to a session. It is not recommended that this feature be used together with the {getPlatformData(props,sendMessageReceiptsReadMap)} API on a message chat page.
  
- To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](!query_Message_Records).
</Warning>

1. Based on the `receiptStatus` field of the {getPlatformData(props,onReceivePeerMessageMap)} callback, Client B determines the receipt status of the message. If this field is set to `PROCESSING`, the message is unread. Developers can call the {getPlatformData(props,sendConversationMessageReceiptReadMap)} API to set all messages sent by Client A in the session as read based on the service logic.
2. Client B determines whether the setting is successful based on {getPlatformData(props,ZIMConversationMessageReceiptReadSentCallbackMap)} .
3. Based on {getPlatformData(props,onConversationMessageReceiptChangedMap)} of {getPlatformData(props,ZIMEventHandlerMap)} , Client A receives a callback notification, indicating that all messages in the session are set as read. Developers can implement the logic of setting all messages sent from the sender in the session as read based on this callback. Developers can implement the service logic of knowing all sent messages in a session are set as read by Client B on Client A based on this callback.

## More features

### Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message

To query the message receipt status, the number of users who have read the message, and the number of users who have not read the message of a message or a batch of messages, call the {getPlatformData(props,queryMessageReceiptsInfoMap)} API. Call {getPlatformData(props,ZIMMessageReceiptsInfoQueriedCallbackMap)} to obtain related information.

<Warning title="Warning">

- If messages sent by other users are queried, the number of users who have read the message and the number of users who have not read the message are **0**.
  
- To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](!query_Message_Records).
</Warning>

### Query the list of members who have or have not read a group message

The In-app Chat SDK supports querying the list of members who have or have not read a group message.

#### Query the list of members who have read a group message

To query the list of members who have read a group message, call the {getPlatformData(props,queryGroupMessageReceiptReadMemberListMap)} API.

<Warning title="Warning">

To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](!query_Message_Records).
</Warning>

#### Query the list of members who have not read a group message

To query the list of members who have not read a group message, call the {getPlatformData(props,queryGroupMessageReceiptUnreadMemberListMap)} API.

<Warning title="Warning">

- If the SDK version is older than 2.16.0, when the number of group members is greater than 100, this API will not return the list of members who have not read a group message. To use this feature, contact ZEGOCLOUD technical support.
  
- To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](!query_Message_Records).
</Warning>

## Sample code

:::if{props.platform=undefined}
```java
// 1. Create an In-app Chat object and introduce the appID, appSign, and Application in Android.
ZIMAppConfig appConfig = new ZIMAppConfig();
appConfig.appID = 12345;    // Enter the appID you applied for from the ZEGOCLOUD Admin Console.
appConfig.appSign = "appSign";    // Enter the appSign you applied for from the ZEGOCLOUD Admin Console.
zim = ZIM.create(appConfig, application);

// 2. Log in to the In-app Chat service.
ZIMUserInfo zimUserInfo = new ZIMUserInfo();
zimUserInfo.userID = "xxxx";
zimUserInfo.userName = "xxxx";
zim.login(zimUserInfo, new ZIMLoggedInCallback() {
    @Override
    public void onLoggedIn(ZIMError error) {
          // Developers can determine whether the login is successful based on ZIMError.          
    }
 });

zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList,
                                             String fromUserID) {
        // Receive a one-to-one message.
    }
    @Override
    public void onMessageReceiptChanged(ZIM zim, ArrayList<ZIMMessageReceiptInfo> infos) {
        // The other user sets a message as read.
    }
    @Override
    public void onConversationMessageReceiptChanged(ZIM zim, ArrayList<ZIMMessageReceiptInfo> infos) {
        // The other user sets all messages in a session as read.
    }
})

String conversationID = "xxx" ; // The session ID

// 3. User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

ZIMTextMessage message = new ZIMTextMessage("test");
ZIMMessageSendConfig sendConfig = new ZIMMessageSendConfig();
sendConfig.hasReceipt = true;    // Set that the messages require a reading receipt.
zim.sendMessage(message, conversationID, ZIMConversationType.PEER,sendConfig, new ZIMMessageSentCallback() {
            @Override
            public void onMessageAttached(ZIMMessage message) {}
            @Override
            public void onMessageSent(ZIMMessage message, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                    // This indicates that the message is sent successfully. receiptStatus of the message is set to PROCESSING. The service layer can display the logic that a message is unread based on this flag.
                }
            }
        });

// 4. User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// 4.1 Set a message as read

List<ZIMMessage> messages = new ArrayList<>();
messages.add(message);
zim.sendMessageReceiptsRead(messages, conversationID, ZIMConversationType.PEER, 
        new ZIMMessageReceiptsReadSentCallback() {
            @Override
            public void onMessageReceiptsReadSent(String conversationID, ZIMConversationType conversationType, 
ArrayList<Long> errorMessageIDs, ZIMError errorInfo) {
             if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                // Callback for setting a message as read.
             }
            }
        });

// 4.2 Set a session as read

zim.sendConversationMessageReceiptRead(conversationID, ZIMConversationType.PEER, 
            new ZIMConversationMessageReceiptReadSentCallback() {
            @Override
            public void onConversationMessageReceiptReadSent(String conversationID, 
                ZIMConversationType conversationType, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                    // A session is read. Developers can listen for this callback to set all messages sent by the sender in this session as read.
                }
            }
        });

// 5. (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.

List<ZIMMessage> messages = new ArrayList<>();
messages.add(message);
zim.queryMessageReceiptsInfo(messages, conversationID, ZIMConversationType.PEER, new ZIMMessageReceiptsInfoQueriedCallback() {
            @Override
            public void onMessageReceiptsInfoQueried(ArrayList<ZIMMessageReceiptInfo> infos, 
                ArrayList<Long> errorMessageIDs, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                    // The status and quantity of this batch of messages are queried, and the corresponding message ID and count are obtained by traversing the information.
                }
            }
        });
// 6. (Optional) Query the list of members who have or have not read a group message.

// 6.1 The list of members who have read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.
zim.queryGroupMessageReceiptReadMemberList(message, groupID, config, 
    new ZIMGroupMessageReceiptMemberListQueriedCallback() {
            @Override
            public void onGroupMessageReceiptMemberListQueried(String groupID, ArrayList<ZIMGroupMemberInfo> userList,
             int nextFlag, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                   // The corresponding member list is queried.
                }
            }
        });

// 6.2 The list of members who have not read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.

zim.queryGroupMessageReceiptUnreadMemberList(message, groupID, config, 
    new ZIMGroupMessageReceiptMemberListQueriedCallback() {
            @Override
            public void onGroupMessageReceiptMemberListQueried(String groupID, ArrayList<ZIMGroupMemberInfo> userList,
             int nextFlag, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                   // The corresponding member list is queried.
                }
            }
        });
```
:::

:::if{props.platform="iOS"}
```objc
// 1. Create an In-app Chat object and introduce the appID and appSign.
ZIMAppConfig *appConfig = [[ZIMAppConfig alloc] init];
appConfig.appID = (unsigned int)appID;    // Enter the appID you applied for from the ZEGOCLOUD Admin Console.
appConfig.appSign = @"appSign";    // Enter the appSign you applied for from the ZEGOCLOUD Admin Console.
self.zim = [ZIM createWithAppConfig: appConfig];

// 2. Log in to the In-app Chat service.
ZIMUserInfo *userInfo = [[ZIMUserInfo alloc]init];
userInfo.userID = @"zegoUser1"; // Enter a value of the NSString type.
userInfo.userName = @"zegotest";// Enter a value of the NSString type.

[self.zim loginWithUserInfo:userInfo callback:^(ZIMError * _Nonnull errorInfo){
    // Developers can determine whether the login is successful based on ZIMError.
}];


- (void)zim:(ZIM *)zim messageReceiptChanged:(NSArray<ZIMMessageReceiptInfo *> *)infos{
     // The other user sets a message as read.
}


- (void)zim:(ZIM *)zim conversationMessageReceiptChanged:(NSArray<ZIMMessageReceiptInfo *> *)infos{
    // The other user sets all messages in a session as read.
}



NSString *conversationID = @"xxx" ; // The session ID.

// 3. User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

ZIMTextMessage *message = [[ZIMTextMessage alloc] init];
ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc]init];
sendConfig.hasReceipt = true;    // Set that the messages require a reading receipt.
[self.zim sendMessage:cmdMsg toUserID:toUserID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // Developers can listen for whether a message is sent successfully through this callback.
    if (errorInfo.code == 0) {
        // This indicates that the message is sent successfully. receiptStatus of the message is set to PROCESSING. The service layer can display the logic that a message is unread based on this flag.
    }
}];


// 4. User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// 4.1 Set a message as read
NSMutableArray<ZIMMessage *> *messageList = [[NSMutableArray alloc] init];

[[ZIM getInstance] sendMessageReceiptsRead:messageList conversationID:@"conversationID" conversationType:conversationType callback:^(NSString * _Nonnull conversationID, ZIMConversationType conversationType, NSArray<NSNumber *> * _Nonnull errorMessageIDs, ZIMError * _Nonnull errorInfo) {
     // Callback for setting a message as read.
}];
// 4.2 Set a session as read
[[ZIM getInstance] sendConversationMessageReceiptRead:@"conversationID" conversationType:conversationType callback:^(NSString * _Nonnull conversationID, ZIMConversationType conversationType, ZIMError * _Nonnull errorInfo) {
    // Callback for setting all messages in a session as read.
}];

// 5. (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.
NSMutableArray<ZIMMessage *> *messageList = [[NSMutableArray alloc] init];
[[ZIM getInstance] queryMessageReceiptsInfoByMessageList:messageList conversationID:conversationID conversationType:conversationType callback:^(NSArray<ZIMMessageReceiptInfo *> * _Nonnull infos, NSArray<NSNumber *> * _Nonnull errorMessageIDs, ZIMError * _Nonnull errorInfo) {
     // The status and quantity of this batch of messages are queried, and the corresponding message ID and count are obtained by traversing the information.
}];


// 6. (Optional) Query the list of members who have or have not read a group message.

// 6.1 The list of members who have read a group message
ZIMGroupMessageReceiptMemberQueryConfig *config =  [[ZIMGroupMessageReceiptMemberQueryConfig alloc]init];
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.
[[ZIM getInstance] queryGroupMessageReceiptReadMemberListByMessage:message groupID:groupID config:config callback:^(NSString * _Nonnull groupID, NSArray<ZIMGroupMemberInfo *> * _Nonnull userList, unsigned int nextFlag, ZIMError * _Nonnull errorInfo)    {
    // The corresponding member list is queried.
}];


// 6.2 The list of members who have not read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.
[[ZIM getInstance] queryGroupMessageReceiptUnreadMemberListByMessage:message groupID:groupID config:config callback:^(NSString * _Nonnull groupID, NSArray<ZIMGroupMemberInfo *> * _Nonnull userList, unsigned int nextFlag, ZIMError * _Nonnull errorInfo) {
    // The corresponding member list is queried.
}];
```
:::
:::if{props.platform="mac"}
```objc
// 1. Create an In-app Chat object and introduce the appID and appSign.
ZIMAppConfig *appConfig = [[ZIMAppConfig alloc] init];
appConfig.appID = (unsigned int)appID;    // Enter the appID you applied for from the ZEGOCLOUD Admin Console.
appConfig.appSign = @"appSign";    // Enter the appSign you applied for from the ZEGOCLOUD Admin Console.
self.zim = [ZIM createWithAppConfig: appConfig];

// 2. Log in to the In-app Chat service.
ZIMUserInfo *userInfo = [[ZIMUserInfo alloc]init];
userInfo.userID = @"zegoUser1"; // Enter a value of the NSString type.
userInfo.userName = @"zegotest";// Enter a value of the NSString type.

[self.zim loginWithUserInfo:userInfo callback:^(ZIMError * _Nonnull errorInfo){
    // Developers can determine whether the login is successful based on ZIMError.
}];


- (void)zim:(ZIM *)zim messageReceiptChanged:(NSArray<ZIMMessageReceiptInfo *> *)infos{
     // The other user sets a message as read.
}


- (void)zim:(ZIM *)zim conversationMessageReceiptChanged:(NSArray<ZIMMessageReceiptInfo *> *)infos{
    // The other user sets all messages in a session as read.
}



NSString *conversationID = @"xxx" ; // The session ID.

// 3. User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

ZIMTextMessage *message = [[ZIMTextMessage alloc] init];
ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc]init];
sendConfig.hasReceipt = true;    // Set that the messages require a reading receipt.
[self.zim sendMessage:cmdMsg toUserID:toUserID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // Developers can listen for whether a message is sent successfully through this callback.
    if (errorInfo.code == 0) {
        // This indicates that the message is sent successfully. receiptStatus of the message is set to PROCESSING. The service layer can display the logic that a message is unread based on this flag.
    }
}];


// 4. User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// 4.1 Set a message as read
NSMutableArray<ZIMMessage *> *messageList = [[NSMutableArray alloc] init];

[[ZIM getInstance] sendMessageReceiptsRead:messageList conversationID:@"conversationID" conversationType:conversationType callback:^(NSString * _Nonnull conversationID, ZIMConversationType conversationType, NSArray<NSNumber *> * _Nonnull errorMessageIDs, ZIMError * _Nonnull errorInfo) {
     // Callback for setting a message as read.
}];
// 4.2 Set a session as read
[[ZIM getInstance] sendConversationMessageReceiptRead:@"conversationID" conversationType:conversationType callback:^(NSString * _Nonnull conversationID, ZIMConversationType conversationType, ZIMError * _Nonnull errorInfo) {
    // Callback for setting all messages in a session as read.
}];

// 5. (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.
NSMutableArray<ZIMMessage *> *messageList = [[NSMutableArray alloc] init];
[[ZIM getInstance] queryMessageReceiptsInfoByMessageList:messageList conversationID:conversationID conversationType:conversationType callback:^(NSArray<ZIMMessageReceiptInfo *> * _Nonnull infos, NSArray<NSNumber *> * _Nonnull errorMessageIDs, ZIMError * _Nonnull errorInfo) {
     // The status and quantity of this batch of messages are queried, and the corresponding message ID and count are obtained by traversing the information.
}];


// 6. (Optional) Query the list of members who have or have not read a group message.

// 6.1 The list of members who have read a group message
ZIMGroupMessageReceiptMemberQueryConfig *config =  [[ZIMGroupMessageReceiptMemberQueryConfig alloc]init];
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.
[[ZIM getInstance] queryGroupMessageReceiptReadMemberListByMessage:message groupID:groupID config:config callback:^(NSString * _Nonnull groupID, NSArray<ZIMGroupMemberInfo *> * _Nonnull userList, unsigned int nextFlag, ZIMError * _Nonnull errorInfo)    {
    // The corresponding member list is queried.
}];


// 6.2 The list of members who have not read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.
[[ZIM getInstance] queryGroupMessageReceiptUnreadMemberListByMessage:message groupID:groupID config:config callback:^(NSString * _Nonnull groupID, NSArray<ZIMGroupMemberInfo *> * _Nonnull userList, unsigned int nextFlag, ZIMError * _Nonnull errorInfo) {
    // The corresponding member list is queried.
}];
```
:::

:::if{props.platform="window"}
```cpp
// 1. Create an In-app Chat object and introduce the appID and appSign.
zim::ZIMAppConfig appConfig;
appConfig.appID = appid;  // Enter the appID you applied for from the ZEGOCLOUD Admin Console.
appConfig.appSign = "appSign";   // Enter the appSign you applied for from the ZEGOCLOUD Admin Console.
zim_ = zim::ZIM::create(appConfig);
zim_->setEventHandler(event_handler_);

// 2. Log in to the In-app Chat service.
zim::ZIMUserInfo userInfo;
userInfo.userID = user_id;
userInfo.userName = user_name;

zim_->login(userInfo, [=](zim::ZIMError errorInfo) {

    if (errorInfo.code == zim::ZIMErrorCode::ZIM_ERROR_CODE_SUCCESS) {
    // You can determine whether the login is successful based on ZIMError.
    }
 });




// 3. User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

zim::ZIMMessageSendConfig sendConfig;
zim::ZIMPushConfig pushConfig;

pushConfig.content = "win_push_content";
pushConfig.payload = "win_push_extended_data";
pushConfig.title = "win_push_title";

sendConfig.priority = zim::ZIM_MESSAGE_PRIORITY_MEDIUM;
sendConfig.pushConfig = &pushConfig;
sendConfig.hasReceipt = true; // Set that the messages require a reading receipt.

auto smessage = std::make_shared<zim::ZIMTextMessage>("test message");

auto notification = std::make_shared<zim::ZIMMessageSendNotification>(
    [=](const std::shared_ptr<zim::ZIMMessage> &message) { 
        
       //  Notification for message being stored in the database
    });

zim_->sendMessage(
    std::static_pointer_cast<zim::ZIMMessage>(smessage), userID,
    zim::ZIMConversationType::ZIM_CONVERSATION_TYPE_PEER, sendConfig, notification,
    [=](const std::shared_ptr<zim::ZIMMessage> &cb_message, const zim::ZIMError &errorInfo) {
        if (errorInfo.code == zim::ZIMErrorCode::ZIM_ERROR_CODE_SUCCESS) {
            // This indicates that the message has been successfully sent. The receiptStatus of the message will be PROCESSING, and the business layer can implement logic to display the unread receipt.
        }
    });


// 4. User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// 4.1 Set a message as read

std::vector<std::shared_ptr<zim::ZIMMessage>> messages;
messages.emplace_back(message);

zim_->sendMessageReceiptsRead(
    messages, conversationID, zim::ZIMConversationType::ZIM_CONVERSATION_TYPE_PEER,
    [=](const std::string &conversationID, zim::ZIMConversationType conversationType,
        const std::vector<long long> &errorMessageIDs,
        const zim::ZIMError &errorInfo) { 
        // Callback for setting a message as read.
    });

// 4.2 Set a session as read

zim_->sendConversationMessageReceiptRead(
    conversationID, zim::ZIMConversationType::ZIM_CONVERSATION_TYPE_PEER,
    [=](const std::string &conversationID, zim::ZIMConversationType conversationType,
        const zim::ZIMError &errorInfo) { 
            // Callback for conversation read receipt. Developers can use this callback to set all messages sent by the other party in this conversation as read.
    });

// 5. (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.

std::vector<std::shared_ptr<zim::ZIMMessage>> messages;
messages.emplace_back(message);
zim_->queryMessageReceiptsInfo(
    messages, conversationID, zim::ZIMConversationType::ZIM_CONVERSATION_TYPE_PEER,
    [=](const std::vector<zim::ZIMMessageReceiptInfo> &infos,
        std::vector<long long> errorMessageIDs, const zim::ZIMError &errorInfo) {});


// 6. (Optional) Query the list of members who have or have not read a group message.

// 6.1 Read user list
zim::ZIMGroupMessageReceiptMemberQueryConfig readMemberQueryConfig;
readMemberQueryConfig.count = 10;    // Number of users to query.
readMemberQueryConfig.nextFlag = 0;    // Query flag, fill in 0 initially, and fill in the flag returned from the callback later.

zim_->queryGroupMessageReceiptReadMemberList(
    message, "group_id", readMemberQueryConfig,
    [=](const std::string &groupID, const std::vector<zim::ZIMGroupMemberInfo> &userList,
        unsigned int nextFlag, const zim::ZIMError &errorInfo) {
                if (errorInfo.code == zim::ZIMErrorCode::ZIM_ERROR_CODE_SUCCESS) {
                   // Query the corresponding member list
                }
        });

// 6.2 Unread user list
zim::ZIMGroupMessageReceiptMemberQueryConfig unreadMemberQueryConfig;
unreadMemberQueryConfig.count = 10;    // Number of users to query.
unreadMemberQueryConfig.nextFlag = 0;    // Query flag, fill in 0 initially, and fill in the flag returned from the callback later.

zim_->queryGroupMessageReceiptUnreadMemberList(
    message, "group_id", unreadMemberQueryConfig,
    [=](const std::string &groupID, const std::vector<zim::ZIMGroupMemberInfo> &userList,
        unsigned int nextFlag, const zim::ZIMError &errorInfo) {
                if (errorInfo.code == zim::ZIMErrorCode::ZIM_ERROR_CODE_SUCCESS) {
                   // Query the corresponding member list
                }
        });
```
:::

:::if{props.platform="Flutter"}
```dart
// 1. Create an In-app Chat object and introduce the appID, appSign, and Application in Android.
ZIMAppConfig appConfig = ZIMAppConfig();
appConfig.appID = 12345;  // Enter the appID you applied for from the ZEGOCLOUD Admin Console.
appConfig.appSign = "appSign";   // Enter the appSign you applied for from the ZEGOCLOUD Admin Console.
zim = ZIM.create(appConfig);

// 2. Log in to the In-app Chat service.
try{
     ZIMLoginConfig loginConfig = ZIMLoginConfig();
     // The user's nickname, leave it blank if you don't want to modify the nickname
    loginConfig.userName = 'userName';
     // If using token as the login authentication method, please fill in this parameter, otherwise no need to fill in
     loginConfig.token = '';
     // Whether this login is an offline login, please refer to the offline login related documentation for details
    loginConfig.isOfflineLogin = false;
    await ZIM.getInstance()?.login('zego', loginConfig);
     // Login successful, write the business logic for successful login
 } on PlatformException catch(onError){
     // Login failed
     // Error code for login failure, please refer to the error code table in the integration documentation to handle
     onError.code;
     // Error message for login failure
     onError.message;
 }
	 
   
   
   
	 
 ZIMEventHandler.onReceivePeerMessage = (zim, messageList, fromUserID) {
 // Receive private chat messages
 };
	 
 ZIMEventHandler.onMessageReceiptChanged = (zim, infos) {
 // The other party has set the message read receipt
= };
	 
 ZIMEventHandler.onConversationMessageReceiptChanged = (zim, infos) {
	      // The other party has set the conversation read receipt
 };


String conversationID = "xxx" ; // The conversation ID

// 3. User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

  ZIMTextMessage message = ZIMTextMessage(message: "test");
  ZIMMessageSendConfig sendConfig = ZIMMessageSendConfig();
  sendConfig.hasReceipt = true; // Set that the messages require a reading receipt.
  ZIM
      .getInstance()!
      .sendMessage(
          message, conversationID, ZIMConversationType.peer, sendConfig)
      .then((result) {
        // This indicates that the message is sent successfully. receiptStatus of the message is set to PROCESSING. The service layer can display the logic that a message is unread based on this flag.
      })
      .catchError((onError) {

      });
// 4. User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// 4.1 Set a message as read

  List<ZIMMessage> messages = [];
  ZIM
      .getInstance()!
      .sendMessageReceiptsRead(
          messages, conversationID, ZIMConversationType.peer)
      .then((result) {
        // Callback for setting a message as read.
      })
      .catchError((onError) {

      });

// 4.2 Set a session as read

  ZIM
      .getInstance()!
      .sendConversationMessageReceiptRead(
          conversationID, ZIMConversationType.peer)
      .then((value) {
        // A session is read. Developers can listen for this callback to set all messages sent by the sender in this session as read.
      })
      .catchError((onError) {

      });

// 5. (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.


List<ZIMMessage> messages = [];
  ZIM
      .getInstance()!
      .queryMessageReceiptsInfo(
          messages, conversationID, ZIMConversationType.peer)
      .then((value) {
        // The status and quantity of this batch of messages are queried, and the corresponding message ID and count are obtained by traversing the information.
      })
      .catchError((onError) {});
// 6. (Optional) Query the list of members who have or have not read a group message.

// 6.1 The list of members who have read a group message
ZIMGroupMessageReceiptMemberQueryConfig config =
      ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.

  ZIM
      .getInstance()!
      .queryGroupMessageReceiptReadMemberList(message, groupID, config)
      .then((result) {
          //  The corresponding member list is queried.
      })
      .catchError((onError) {

      });

// 6.2 The list of members who have not read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.

  ZIM
      .getInstance()!
      .queryGroupMessageReceiptUnreadMemberList(message, groupID, config)
      .then((result) {
          // The corresponding member list is queried.
      })
      .catchError((onError) {

      });
```
:::

:::if{props.platform="U3d"}
```c#
// 1. Create a ZIM object and pass in the appID and appSign
ZIMAppConfig appConfig = new ZIMAppConfig();
appConfig.appID = 12345;  // Replace with the AppID you obtained from the ZEGO Console
appConfig.appSign = "appSign";   // Replace with the AppSign you obtained from the ZEGO Console
ZIM.Create(appConfig);

// 2. Log in
ZIMUserInfo zimUserInfo = new ZIMUserInfo();
zimUserInfo.userID = "xxxx";
zimUserInfo.userName = "xxxx";
ZIM.GetInstance().Login(zimUserInfo, (ZIMError errorInfo) =>
{
    // Developers can use ZIMError to determine if the login is successful.
});

ZIM.GetInstance().onMessageReceiptChanged = (ZIM zim, List<ZIMMessageReceiptInfo> infos) =>
{
    // Group message receipt status changed
};

ZIM.GetInstance().onConversationMessageReceiptChanged = (ZIM zim, List<ZIMMessageReceiptInfo> infos) =>
{
    // Conversation message receipt status changed
};

string conversationID = "xxx"; // Conversation ID

// 3. User A sends a message with receipt, taking a peer-to-peer text message as an example

ZIMTextMessage message = new ZIMTextMessage("test");
ZIMMessageSendConfig sendConfig = new ZIMMessageSendConfig();
sendConfig.hasReceipt = true;    // Set the message with receipt
ZIMMessageSendNotification notification = new ZIMMessageSendNotification();
ZIM.GetInstance().SendMessage(message, "conversationID", ZIMConversationType.Peer, sendConfig, notification,
    (ZIMMessage message, ZIMError errorInfo) => { });

// 4. User B receives the receipt and marks it as read, choose one of the following interfaces

// 4.1 Message read

List<ZIMMessage> messages = new List<ZIMMessage>();
messages.Add(message);
ZIM.GetInstance().SendMessageReceiptsRead(messages, "conversationID", ZIMConversationType.Peer, (string conversationID, ZIMConversationType conversationType,
                   List<long> errorMessageIDs, ZIMError errorInfo) =>
{
    // Callback for sending message read
});

// 4.2 Conversation read

ZIM.GetInstance().SendConversationMessageReceiptRead("conversationID", ZIMConversationType.Peer, (string conversationID, ZIMConversationType conversationType,
                           ZIMError errorInfo) =>
{
    // Callback for sending conversation message read
});

// 5. (Optional) Query the receipt status, unread user count, and read user count for a batch of messages

List<ZIMMessage> queryMessages = new List<ZIMMessage>();
queryMessages.Add(message);
ZIM.GetInstance().QueryMessageReceiptsInfo(queryMessages, "conversationID", ZIMConversationType.Peer, (List<ZIMMessageReceiptInfo> infos, List<long> errorMessageIDs,
                           ZIMError errorInfo) =>
{ });

// 6. (Optional) Query the list of read group members and unread group members for a specific group message

// 6.1 List of read users
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The flag for querying, fill in 0 initially, and then fill in the flag returned from the callback.
config.count = 10;    // The number of users to query.

ZIM.GetInstance().QueryGroupMessageReceiptReadMemberList(message, "groupID", config, (string groupID, List<ZIMGroupMemberInfo> userList,
                           uint nextFlag, ZIMError errorInfo) =>
{ });

// 6.2 List of unread users
ZIMGroupMessageReceiptMemberQueryConfig groupMessageReceiptMemberQueryConfig = new ZIMGroupMessageReceiptMemberQueryConfig();
groupMessageReceiptMemberQueryConfig.nextFlag = 0;    // The flag for querying, fill in 0 initially, and then fill in the flag returned from the callback.
groupMessageReceiptMemberQueryConfig.count = 10;    // The number of users to query.

ZIM.GetInstance().QueryGroupMessageReceiptUnreadMemberList(message, "groupID", groupMessageReceiptMemberQueryConfig, (string groupID, List<ZIMGroupMemberInfo> userList,
                           uint nextFlag, ZIMError errorInfo) => { });
```

:::

:::if{props.platform="Web"}
```javascript
// 1. Register a callback.

// Receive a one-to-one message.
zim.on('receivePeerMessage', function (zim, { messageList, fromConversationID }) {
    console.log('receivePeerMessage', messageList, fromConversationID);
});
// The other user sets a message as read.
zim.on('messageReceiptChanged', function (zim, { infos }) {
    console.log('messageReceiptChanged', infos);
});
// The other user sets all messages in a session as read.
zim.on('conversationMessageReceiptChanged', function (zim, { infos }) {
    console.log('conversationMessageReceiptChanged', infos);
});

var userID_A = "xxxx" ;    // The ID of user A.
var userID_B = "xxxx" ;    // The ID of user B.

// 2. User A sends a message that requires a reading receipt to user B. A text one-to-one message is used as an example.

var messageObj = { type: 1, message: 'text receipt message' }
var config = {
    priority: 1,    // Message priority. Valid values: 1: Low (default), 2: Medium, 3: High
    hasReceipt: true    // Set that the messages require a reading receipt.
}
var notification = {
    onMessageAttached: function(message) {
        // todo: Loading
    }
}

zim.sendMessage(messageObj, userID_B, 0, config, notification)
    .then(function ({ message }) {
        // Sent successfully.
    })
    .catch(function (err) {
        // Sending failed.
    });

// 3. User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// 3.1 Set a message as read
var messages = [];    // Queried from queryHistoryMessage or received from receivePeerMessage
zim.sendMessageReceiptsRead(messages, userID_A, 0)    
    .then(function ({ conversationID, conversationType, errorMessageIDs }) {
        // The operation is successful. Messages that failed to be set as read are returned through errorMessageIDs.
    })
    .catch(function (err) {
        // The operation fails.
    });

// 3.2 Set a session as read
zim.sendConversationMessageReceiptRead(userID_A, 0)
    .then(function ({ conversationID, conversationType }) {
        // The operation is successful. User B can set all messages sent from user A in this session as read.
    })
    .catch(function (err) {
        // The operation fails.
    });

// 4. (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.

var messages = []; // Queried from queryHistoryMessage
zim.queryMessageReceiptsInfo(messages, userID_B, 0)    
    .then(function ({ infos, errorMessageIDs }) {
        // The operation is successful. Messages that failed to be queried are returned through errorMessageIDs.
    })
    .catch(function (err) {
        // The operation fails.
    });

// 5. (Optional) Query the list of members who have or have not read a group message.

var groupMsgObj = {}    // Queried from queryHistoryMessage
var queryConfig = {
    count: 10,    // The user quantity to be queried.
    nextFlag: 0    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in Promise.
}

// 5.1 The list of members who have read a group message
zim.queryGroupMessageReceiptReadMemberList(groupMsgObj, groupMsgObj.conversationID, queryConfig)
    .then(function ({ nextFlag, userList, groupID }) {
        // The operation is successful.
    })
    .catch(function (err) {
        // The operation fails.
    });

// 5.2 The list of members who have not read a group message
zim.queryGroupMessageReceiptUnreadMemberList(groupMsgObj, groupMsgObj.conversationID, queryConfig)
    .then(function ({ nextFlag, userList, groupID }) {
        // The operation is successful.
    })
    .catch(function (err) {
        // The operation fails.
    });
```
:::