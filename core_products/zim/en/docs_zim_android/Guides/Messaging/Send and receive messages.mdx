---
articleID: 14227
---

import {getPlatformData} from "/snippets/utils-content-parser.js"

export const setEventHandlerMap = {
  'Android': <a href='@setEventHandler' target='_blank'>setEventHandler</a>,
}
export const ZIMTextMessageMap = {
  'Android': <a href='@-ZIMTextMessage' target='_blank'>ZIMTextMessage</a>,
}
export const ZIMCommandMessageMap = {
  'Android': <a href='@-ZIMCommandMessage' target='_blank'>ZIMCommandMessage</a>,
}
export const receivePeerMessageMap = {
  'Android': <a href='@onReceivePeerMessage' target='_blank'>onReceivePeerMessage</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
}
export const sendMessageMap = {
  'Android': <a href='@sendMessage' target='_blank'>sendMessage</a>,
}
export const onReceivePeerMessageMap = {
  'Android': <a href='@onReceivePeerMessage' target='_blank'>onReceivePeerMessage</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
}
export const onReceiveRoomMessageMap = {
  'Android': <a href='@onReceiveRoomMessage' target='_blank'>onReceiveRoomMessage</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-room-message-from-room-id' target='_blank'>onReceiveRoomMessage</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-room-message-from-room-id' target='_blank'>onReceiveRoomMessage</a>,
}
export const onReceiveGroupMessageMap = {
  'Android': <a href='@onReceiveGroupMessage' target='_blank'>onReceiveGroupMessage</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-group-message-from-group-id' target='_blank'>onReceiveGroupMessage</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-group-message-from-group-id' target='_blank'>onReceiveGroupMessage</a>,
}
export const sendMediaMessageMap = {
  'Android': <a href='@sendMediaMessage' target='_blank'>sendMediaMessage</a>,
}
export const onMediaUploadingProgressMap = {
  'Android': <a href='@onMediaUploadingProgress' target='_blank'>onMediaUploadingProgress</a>,
}
export const downloadMediaFileWithMessageMap = {
  'Android': <a href='@downloadMediaFile' target='_blank'>downloadMediaFile</a>,
  'iOS,mac': <a href='@downloadMediaFileWithMessage' target='_blank'>downloadMediaFileWithMessage</a>,
}
export const onMediaDownloadingProgressMap = {
  'Android': <a href='@onMediaDownloadingProgress' target='_blank'>onMediaDownloadingProgress</a>,
  'iOS,mac': <a href='@ZIMMediaDownloadingProgress' target='_blank'>ZIMMediaDownloadingProgress</a>,
}
export const ZIMCustomMessageMap = {
  'Android': <a href='@-ZIMCustomMessage' target='_blank'>ZIMCustomMessage</a>,
}
export const ZIMMessageMap = {
  'Android': <a href='@-ZIMMessage' target='_blank'>ZIMMessage</a>,
}
export const setMentionedUserIDsMap = {
  'Android': "`setMentionedUserIDs`",
  'iOS,mac': <a href='@mentionedUserIDs-ZIMMessage' target='_blank'>mentionedUserIDs</a>,
}
export const isMentionAllMap = {
  'Android': <a href='@isMentionAll-ZIMMessage' target='_blank'>isMentionAll</a>,
}
export const mentionedInfoListMap = {
  'Android': <a href='@mentionedInfoList-ZIMConversation' target='_blank'>mentionedInfoList</a>,
}
export const ZIMMessageMentionedTypeMap = {
  'Android': <a href='@-ZIMMessageMentionedType' target='_blank'>ZIMMessageMentionedType</a>,
}
export const onConversationChangedMap = {
  'Android': <a href='@onConversationChanged' target='_blank'>onConversationChanged</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-conversation-changed' target='_blank'>conversationChanged</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-conversation-changed' target='_blank'>conversationChanged</a>,
}
export const ZIMConversationMap = {
  'Android': <a href='@-ZIMConversation' target='_blank'>ZIMConversation</a>,
}
export const queryConversationListWithConfigMap = {
  'Android': <a href='@queryConversationList' target='_blank'>queryConversationList</a>,
  'iOS,mac': <a href='@queryConversationListWithConfig' target='_blank'>queryConversationListWithConfig</a>,
}
export const queryConversationMap = {
  'Android': <a href='@queryConversation' target='_blank'>queryConversation</a>,
}
export const clearConversationUnreadMessageCountMap = {
  'Android': <a href='@clearConversationUnreadMessageCount' target='_blank'>clearConversationUnreadMessageCount</a>,
}
export const clearConversationTotalUnreadMessageCountMap = {
  'Android': <a href='@clearConversationTotalUnreadMessageCount' target='_blank'>clearConversationTotalUnreadMessageCount</a>,
}
export const onBroadcastMessageReceivedMap = {
  'Android': <a href='@onBroadcastMessageReceived' target='_blank'>onBroadcastMessageReceived</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-broadcast-message-received' target='_blank'>broadcastMessageReceived</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-broadcast-message-received' target='_blank'>broadcastMessageReceived</a>,
}
export const onMessageSentStatusChangedMap = {
  'Android': <a href='@onMessageSentStatusChanged' target='_blank'>onMessageSentStatusChanged</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-message-sent-status-changed' target='_blank'>messageSentStatusChanged</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-message-sent-status-changed' target='_blank'>messageSentStatusChanged</a>,
}

# Send & Receive messages

- - -

ZEGOCLOUD's In-app Chat (the ZIM SDK) provides the capability of message management, allowing you to send and receive one-to-one, group, in-room messages, query message history, delete messages, and more. With the message management feature, you can meet different requirements of various scenarios such as social entertainment, online shopping, online education, interactive live streaming, and more. 

This document describes how to send and receive messages with the ZIM SDK. 

## Message types

<table>
<tbody><tr data-row-level="1">
<th>Message Type</th>
<th>Description</th>
<th>Feature and Scenario</th>
</tr>
<tr data-row-level="2">
<td>ZIMTextMessage(1)</td>
<td>The text message. A text message cannot exceed 32 KB in size, and up to 10 text messages can be sent per second per client.</td>
<td>
Text messages are reliable and in order and can be stored as historical messages, applicable to one-to-one chats, group chats, and on-screen comments in chat rooms. After a room is disbanded, messages in it are not stored.

API: {getPlatformData(props,sendMessageMap)} 
</td>
</tr>
<tr data-row-level="3">
<td>ZIMCommandMessage(2)</td>
<td>The signaling message whose content can be customized. A signaling message cannot exceed 5 KB in size, and up to 10 signaling messages can be sent per second per client.</td>
<td>
Signaling messages are applicable to signaling transmission (for example, co-hosting, virtual gifting, and course materials sending) in scenarios with a higher concurrency, such as chat rooms and online classrooms.

API: {getPlatformData(props,sendMessageMap)} 
</td>
</tr>
<tr data-row-level="4">
<td>ZIMBarrageMessage(20)</td>
<td>The on-screen comment in a chat room. An on-screen comment cannot exceed 5 KB in size, and there is no limit on the number of comments that can be sent per second per client.</td>
<td>
<p>On-screen comments are usually unreliable messages that are sent at a high frequency and can be discarded.</p><p>A high concurrency is supported, but reliability cannot be guaranteed.</p>

API: {getPlatformData(props,sendMessageMap)} 
</td>
</tr>
<tr data-row-level="5">
<td>ZIMImageMessage(11)</td>
<td>The image message. Mainstream image formats, such as JPG, PNG, BMP, TIFF, GIF, and WebP, are supported. An image message cannot exceed 10 MB in size, and up to 10 image messages can be sent per second per client.</td>
<td rowspan="4">
Image messages are reliable and in order and can be stored as historical messages (for 14 days by default), usually applicable to one-to-one chats, chat rooms, and group chats.

API: {getPlatformData(props,sendMessageMap)} 
</td>
</tr>
<tr data-row-level="6">
<td>ZIMFileMessage(12)</td>
<td>The file message. A file message contains a file of any format and cannot exceed 100 MB in size. Up to 10 file messages can be sent per second per client.</td>
</tr>
<tr data-row-level="7">
<td>ZIMAudioMessage(13)</td>
<td>The audio message. An audio message contains an MP3 or M4A audio of up to 300 seconds and cannot exceed 6 MB in size. Up to 10 audio messages can be sent per second per client.</td>
</tr>
<tr data-row-level="8">
<td>ZIMVideoMessage(14)</td>
<td>
The video message. A video message contains an MP4 or MOV video and cannot exceed 100 MB in size. Up to 10 video messages can be sent per second per client. 

**The width and height of the first frame of a video can be obtained after successful message sending only if the video is H.264- or H.265-encoded.**
</td>
</tr>
<tr data-row-level="9">
<td>ZIMCombineMessage(100)</td>
<td>Merge messages, there is no limit on message size, and the sending frequency of a single client is limited to 10 times/second.</td>
<td>
Text messages are reliable and in order and can be stored as historical messages, applicable to real-time chat scenarios such as one-to-one chats, room, group chats, etc.

API: {getPlatformData(props,sendMessageMap)} 
</td>
</tr>
<tr data-row-level="10">
<td>ZIMCustomMessage(200)</td>
<td>The custom message. You can customize the message type and parse the message without using the ZIM SDK.</td>
<td>
Custom messages are usually applicable to votes, solitaire, and video cards.

API: {getPlatformData(props,sendMessageMap)} 
</td>
</tr>
</tbody>
</table>


## Send/Receive regular messages

Regular messages refer to the messages of the following message types: ZIMTextMessage and ZIMBarrageMessage.

<Warning title="Warning">

- To receive event callbacks (receive messages, get connection status, and receive a notification when Token is about to expire, etc.), you can set up the {getPlatformData(props,setEventHandlerMap)} method and listen for related events. 
- When receiving messages, you need to determine the message is a Text message {getPlatformData(props,ZIMTextMessageMap)} or a Command message {getPlatformData(props,ZIMCommandMessageMap)} because these two message types are based on the basic message class {getPlatformData(props,ZIMMessageMap)}. You need to convert the basic message class to a concrete message type and then retrieve the message content from the `message` field.
- When a message is received, it can be sorted using the message's `orderKey`. The larger the `orderKey`, the newer the message. And the number of unread messages will be updated automatically upon receiving.
</Warning>


### Send/Receive messages

The following process shows how Client A sends messages to Client B:

<Frame width="512" height="auto" caption=""><img src="https://storage.zego.im/sdk-doc/Pics/In_app_Chat/14226.png" /></Frame>

1. Client A and Client B create their own ZIM SDK instances, and set up an event handler {getPlatformData(props,setEventHandlerMap)} to listen for the callback on the result of message sending {getPlatformData(props,receivePeerMessageMap)}.
2. Client A and Client B log in to the ZIM SDK.
3. Client A calls the {getPlatformData(props,sendMessageMap)} method, and set the `converversationType` to `ZIMConversationTypePeer` to send a one-to-one message to Client B.
4. Client B listens for the {getPlatformData(props,receivePeerMessageMap)} callback to receive Client A's messages.

<Warning title="Warning">

You can't send messages to yourself by calling the `sendMessage` method (when toConversationID = your ID). If you did so, the error code 6000001 will return. 

</Warning>

#### Send messages

:::if{props.platform=undefined}
<CodeGroup>
```java SampleCode
//  1. Create a ZIM SDK object with the AppID and AppSign you get, and the Application of the Android app.
ZIMAppConfig appConfig = new ZIMAppConfig();
appConfig.appID = 12345;  // The AppID you get.
appConfig.appSign = "appSign";   // The AppSign you get.
zim = ZIM.create(appConfig, application);

// 2. Set up a setEventHandler.
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        // Callback on the one-on-one message received.
    }
});

// 3. Log in
ZIMUserInfo zimUserInfo = new ZIMUserInfo();
zimUserInfo.userID = "xxxx";
zimUserInfo.userName = "xxxx";
zim.login(zimUserInfo, new ZIMLoggedInCallback() {
    @Override
    public void onLoggedIn(ZIMError error) {
          // You can be told whether the login is successful according to the ZIMError.         
    }
 });

// 4. Send regular messages
String toConversationID = "xxxx1";

ZIMTextMessage zimMessage = new ZIMTextMessage();
zimMessage.message = "Message content";

ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// Set the message priority.
config.priority = ZIMMessagePriority.LOW;
// Set up the configurations of the offline notifications.
// Offline push configuration of room messages is not supported. If you need to send room offline messages, please contact ZEGOCLOUD technical support team to activate relevant permissions.
ZIMPushConfig pushConfig = new ZIMPushConfig();
pushConfig.title = "Offline notification title";
pushConfig.content= "Offline notification content";
pushConfig.extendedData = "Extension info of the offline notification";
config.pushConfig = pushConfig;

// Set conversation type. Set it based on your conversation type.
// Send one-on-one messages. 
ZIMConversationType type = ZIMConversationType.Peer;

// Send group messages. 
ZIMConversationType type = ZIMConversationType.Gourp;

// Send in-room messages.
ZIMConversationType type = ZIMConversationType.Room;

// 5. Send messages.

zim.sendMessage(zimMessage, toConversationID, type,config, new ZIMMessageSentCallback() {
    @Override
    public void onMessageAttached(ZIMMessage zimMessage) {
    // You can use this callback to monitor whether the message is ready to be sent. This callback will be thrown only if the message passes the local basic parameter verification, otherwise an error will be thrown through the onMessageSent callback.
    }

    @Override
    public void onMessageSent(ZIMMessage zimMessage, ZIMError error) {
    // You can use this callback to monitor whether the message is ready to be sent. This callback will be thrown only if the message passes the local basic parameter verification, otherwise an error will be thrown through the onMessageSent callback.
    }
});
```
</CodeGroup>
:::
:::if{props.platform="mac"}
<CodeGroup>
```objc SampleCode
// 1. Create a ZIM SDK object with the AppID and AppSign you get.
ZIMAppConfig *appConfig = [[ZIMAppConfig alloc] init];
appConfig.appID = (unsigned int)appID;     // The AppID you get.
appConfig.appSign = @"appSign";     // The AppSign you get.
self.zim = [ZIM createWithAppConfig: appConfig];

// 2. Set up a setEventHandler.
[self.zim setEventHandler:self];

// 3. Log in
ZIMUserInfo *userInfo = [[ZIMUserInfo alloc] init];
userInfo.userID = @"xxxx";
userInfo.userName = @"xxxx";
[self.zim loginWithUserInfo:userInfo callback:^(ZIMError * _Nonnull errorInfo){
    // You can be told whether the login is successful according to the ZIMError.
}];

NSString *toConversationID = @"xxxx1";

ZIMTextMessage *textMessage = [[ZIMTextMessage alloc] init];
textMessage.message = @"Message content";

ZIMMessageSendConfig *config = [[ZIMMessageSendConfig alloc] init];
// Set the message priority.
config.priority = ZIMMessagePriorityLow;
// Set up the configurations of the offline notifications. To use this, enable this feature first. 
ZIMPushConfig *pushConfig = [[ZIMPushConfig alloc] init];
pushConfig.title = @"Offline notification title";
pushConfig.content= @"Offline notification content";
pushConfig.extendedData = @"Extension info of the offline notification";
config.pushConfig = pushConfig

ZIMMessageSendNotification *notification = [[ZIMMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // The callback on the message not sent yet. Before the message is sent, you can get a temporary ZIMMessage message for you to implement your business logic as needed. 
};

// 4. Set conversation type. Set it based on your conversation type.
// Send one-on-one messages. 
ZIMConversationType type = ZIMConversationTypePeer;

// Send group messages. 
ZIMConversationType type = ZIMConversationTypeGroup;

// Send in-room messages.
ZIMConversationType type = ZIMConversationTypeRoom;

// 5. Send messages.
[self.zim sendMessage:textMessage toConversationID:toConversationID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // You can listen for this callback for the message sending results.
}];
```
</CodeGroup>
:::
:::if{props.platform="iOS"}
<CodeGroup>
```objc SampleCode
// 1. Create a ZIM SDK object with the AppID and AppSign you get.
ZIMAppConfig *appConfig = [[ZIMAppConfig alloc] init];
appConfig.appID = (unsigned int)appID;     // The AppID you get.
appConfig.appSign = @"appSign";     // The AppSign you get.
self.zim = [ZIM createWithAppConfig: appConfig];

// 2. Set up a setEventHandler.
[self.zim setEventHandler:self];

// 3. Log in
ZIMUserInfo *userInfo = [[ZIMUserInfo alloc] init];
userInfo.userID = @"xxxx";
userInfo.userName = @"xxxx";
[self.zim loginWithUserInfo:userInfo callback:^(ZIMError * _Nonnull errorInfo){
    // You can be told whether the login is successful according to the ZIMError.
}];

NSString *toConversationID = @"xxxx1";

ZIMTextMessage *textMessage = [[ZIMTextMessage alloc] init];
textMessage.message = @"Message content";

ZIMMessageSendConfig *config = [[ZIMMessageSendConfig alloc] init];
// Set the message priority.
config.priority = ZIMMessagePriorityLow;
// Set up the configurations of the offline notifications. To use this, enable this feature first. 
ZIMPushConfig *pushConfig = [[ZIMPushConfig alloc] init];
pushConfig.title = @"Offline notification title";
pushConfig.content= @"Offline notification content";
pushConfig.extendedData = @"Extension info of the offline notification";
config.pushConfig = pushConfig

ZIMMessageSendNotification *notification = [[ZIMMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // The callback on the message not sent yet. Before the message is sent, you can get a temporary ZIMMessage message for you to implement your business logic as needed. 
};

// 4. Set conversation type. Set it based on your conversation type.
// Send one-on-one messages. 
ZIMConversationType type = ZIMConversationTypePeer;

// Send group messages. 
ZIMConversationType type = ZIMConversationTypeGroup;

// Send in-room messages.
ZIMConversationType type = ZIMConversationTypeRoom;

// 5. Send messages.
[self.zim sendMessage:textMessage toConversationID:toConversationID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // You can listen for this callback for the message sending results.
}];
```
</CodeGroup>
:::



#### Receive messages


<Note title="Note">

- To send messages, call the {getPlatformData(props,sendMessageMap)} method and set the `ZIMConversationType` accordingly.
- To receive messages:
    - One-on-one messages (Peer type), through the callback {getPlatformData(props,onReceivePeerMessageMap)}.
    - In-room messages (Room type), through the callback {getPlatformData(props,onReceiveRoomMessageMap)}.
    - Group messages (Group type), through the callback {getPlatformData(props,onReceiveGroupMessageMap)}.
</Note>

:::if{props.platform=undefined}
<CodeGroup>
```java SampleCode
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        // Callback for receiving one-to-one messages. 
        for (ZIMMessage zimMessage : messageList) {
           if (zimMessage instanceof ZIMTextMessage) {
                ZIMTextMessage zimTextMessage = (ZIMTextMessage) zimMessage;
                Log.e(TAG, "The text message you received:"+ zimTextMessage.message);
           } else if (zimMessage instanceof ZIMCommandMessage) {
                ZIMCommandMessage zimCommandMessage = (ZIMCommandMessage) zimMessage;
                Log.e(TAG, "The signaling message you received:"+ zimCommandMessage.message);
           }    
        }
    }

    @Override
    public void onReceiveGroupMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromGroupID) {
        // Callback for receiving group messages. 
        for (ZIMMessage zimMessage : messageList) {
           if (zimMessage instanceof ZIMTextMessage) {
                ZIMTextMessage zimTextMessage = (ZIMTextMessage) zimMessage;
                Log.e(TAG, "The text message you received:"+ zimTextMessage.message);
           } else if (zimMessage instanceof ZIMCommandMessage) {
                ZIMCommandMessage zimCommandMessage = (ZIMCommandMessage) zimMessage;
                Log.e(TAG, "The signaling message you received:"+ zimCommandMessage.message);
           }    
        }
    }

    @Override
    public void onReceiveRoomMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromRoomID) {
        // Callback for receiving in-room messages. 
        for (ZIMMessage zimMessage : messageList) {
           if (zimMessage instanceof ZIMTextMessage) {
                ZIMTextMessage zimTextMessage = (ZIMTextMessage) zimMessage;
                Log.e(TAG, "The text message you received:"+ zimTextMessage.message);
           } else if (zimMessage instanceof ZIMCommandMessage) {
                ZIMCommandMessage zimCommandMessage = (ZIMCommandMessage) zimMessage;
                Log.e(TAG, "The signaling message you received:"+ zimCommandMessage.message);
           }    
        }
    }
});
```
</CodeGroup>
:::
:::if{props.platform="mac"}
<CodeGroup>
```objc SampleCode
// Set up a ZIMEventHander and listen for related callbacks.
[zim setEventHandler:self];

// Callback for receiving the one-to-one message.
- (void)zim:(ZIM *)zim
    receivePeerMessage:(NSArray<ZIMMessage *> *)messageList
            fromUserID:(NSString *)fromUserID{
     // Implement your event handling logic after receiving the message here. 
}

// Callback for receiving the group message.
- (void)zim:(ZIM *)zim
    receiveGroupMessage:(NSArray<ZIMMessage *> *)messageList
            fromGroupID:(NSString *)fromGroupID{
    // Implement your event handling logic after receiving the message here. 
}

// Callback for receiving the in-room message.
- (void)zim:(ZIM *)zim
    receiveRoomMessage:(NSArray<ZIMMessage *> *)messageList
            fromRoomID:(NSString *)fromRoomID{
    // Implement your event handling logic after receiving the message here. 
}
```
</CodeGroup>
:::
:::if{props.platform="iOS"}
<CodeGroup>
```objc SampleCode
// Set up a ZIMEventHander and listen for related callbacks.
[zim setEventHandler:self];

// Callback for receiving the one-to-one message.
- (void)zim:(ZIM *)zim
    receivePeerMessage:(NSArray<ZIMMessage *> *)messageList
            fromUserID:(NSString *)fromUserID{
     // Implement your event handling logic after receiving the message here. 
}

// Callback for receiving the group message.
- (void)zim:(ZIM *)zim
    receiveGroupMessage:(NSArray<ZIMMessage *> *)messageList
            fromGroupID:(NSString *)fromGroupID{
    // Implement your event handling logic after receiving the message here. 
}

// Callback for receiving the in-room message.
- (void)zim:(ZIM *)zim
    receiveRoomMessage:(NSArray<ZIMMessage *> *)messageList
            fromRoomID:(NSString *)fromRoomID{
    // Implement your event handling logic after receiving the message here. 
}
```
</CodeGroup>
:::

## Send/Receive rich media content


The ZIM SDK now supports sending and receiving messages of different rich media types, such as images, audio, video, and files. To send and receive rich media content, refer to the following:

1. To send rich media content after login, you will need to specify the message type (image, file, audio, video) first and then the session type (one-on-one chat, room chat, group chat).
2. For a receiver to receive and download the rich media content, set up and listen for related event callbacks based on the session type (one-on-one chat, room chat, group chat) after logging in.

### Send rich media content


To send rich media content after login, call the {getPlatformData(props,sendMediaMessageMap)} method, and specify the message type (image, file, audio, video), the session type (one-on-one chat, room chat, group chat), and message related configurations as needed.

<Warning title="Warning">

- When sending rich media content, the file path to be sent must be in `UTF-8` encoding format.
- To send rich media content to a room/group, the sender must be in the room/group.
</Warning>



:::if{props.platform=undefined}
<CodeGroup>
```java
// Send rich media content in one-on-one chat - Send images:
ZIMImageMessage message = new ZIMImageMessage("/storage/emulated/0/Android/data/packagename/picture/xxx.jpg");
// If a network URL is entered here, the SDK will pass through the path without ZIM background service processing. If both the network URL and the local path are entered, the SDK will prioritize the network URL that you want to use.
message.setLargeImageDownloadUrl("url");
message.setFileDownloadUrl("url");
message.setThumbnailDownloadUrl("url");
ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// Set message priority. 
config.priority = ZIMMessagePriority.LOW;
// Set up the configurations of the offline notifications.
ZIMPushConfig pushConfig = new ZIMPushConfig();
pushConfig.title = "Offline notification title";
pushConfig.content= "Offline notification content";
pushConfig.extendedData = "Extension info of the offline notification";
config.pushConfig = pushConfig;

zim.sendMediaMessage(message, toConversationID, ZIMConversationType.PEER, config, new ZIMMediaMessageSentCallback() {
    @Override
    public void onMessageSent(ZIMMessage message, ZIMError errorInfo) {
     // You can use this callback to monitor whether the message is ready to be sent. This callback will be thrown only if the message passes the local basic parameter verification, otherwise an error will be thrown through the onMessageSent callback.ã€‚                    
    }

    @Override
    public void onMessageAttached(ZIMMediaMessage message){
    
    }

    @Override
    public void onMediaUploadingProgress(String fileUID, long currentFileSize, long totalFileSize, ZIMMediaMessage message) {
         // You can use this callback to monitor whether the message is sent successfully.              
    }
});
```
</CodeGroup>
:::
:::if{props.platform="mac"}
<CodeGroup>
```objc SampleCode
// Send rich media content in one-on-one chat - Send images:
ZIMImageMessage *imgMsg = [[ZIMImageMessage alloc] init];

// Fill in a UTF-8 local path (the path to the local picture is recommended)
// The following uses a temporary image path as an example:
imgMsg.fileLocalPath = @"/private/var/mobile/Containers/Data/Application/C142EFE6-9DEC-449D-89B7-BF99F2578F98/tmp/D1513E30-2641-440B-B897-48CD43BE1D04.jpeg";

// If a network URL is entered here, the SDK will pass through the path without ZIM background service processing. If both the network URL and the local path are entered, the SDK will prioritize the network URL that you want to use.
imgMsg.fileDownloadUrl = @"";

ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = 1;
        
ZIMMediaMessageSendNotification *notification = [[ZIMMediaMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // Implement your event handling logic before the message is sent. 
};
        
notification.onMediaUploadingProgress = ^(ZIMMediaMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
    // You can listen for the callback to know the progress of the rich media message you sent.
};

[[ZIM getInstance] sendMediaMessage:imgMsg toConversationID:@"conversationID" conversationType:ZIMConversationTypePeer config:sendConfig notification:notification callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
        
}];
```
</CodeGroup>
:::
:::if{props.platform="iOS"}
<CodeGroup>
```objc SampleCode
// Send rich media content in one-on-one chat - Send images:
ZIMImageMessage *imgMsg = [[ZIMImageMessage alloc] init];

// Fill in a UTF-8 local path (the path to the local picture is recommended)
// The following uses a temporary image path as an example:
imgMsg.fileLocalPath = @"/private/var/mobile/Containers/Data/Application/C142EFE6-9DEC-449D-89B7-BF99F2578F98/tmp/D1513E30-2641-440B-B897-48CD43BE1D04.jpeg";

// If a network URL is entered here, the SDK will pass through the path without ZIM background service processing. If both the network URL and the local path are entered, the SDK will prioritize the network URL that you want to use.
imgMsg.fileDownloadUrl = @"";

ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = 1;
        
ZIMMediaMessageSendNotification *notification = [[ZIMMediaMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // Implement your event handling logic before the message is sent. 
};
        
notification.onMediaUploadingProgress = ^(ZIMMediaMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
    // You can listen for the callback to know the progress of the rich media message you sent.
};

[[ZIM getInstance] sendMediaMessage:imgMsg toConversationID:@"conversationID" conversationType:ZIMConversationTypePeer config:sendConfig notification:notification callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
        
}];
```
</CodeGroup>
:::


#### Callback for the sending progress of rich media content


You will be notified of the sending progress of rich media content through the callback {getPlatformData(props,onMediaUploadingProgressMap)}.

Among which:

- message: The content of the message being sent.
- currentFileSiz: The size of the message that has been sent.
- totalFileSize: The overall size of the message sent.



### Receive rich media content

To receive the rich media content messages, do the following:
1. Listen for the following callbacks based on the session type (one-on-one chat, room chat, group chat): {getPlatformData(props,onReceivePeerMessageMap)}, {getPlatformData(props,onReceiveRoomMessageMap)}, {getPlatformData(props,onReceiveGroupMessageMap)}.
2. Call the {getPlatformData(props,downloadMediaFileWithMessageMap)} method to download the rich media content.

When downloading rich media content, you need to specify the file type of the corresponding media messages first.

- Image messages: You can choose to download the original file, large view, or thumbnail.
- Files/Audio messages: Only original files/audio files can be downloaded.
- Video messages: You can choose to download the original video file and the thumbnail of the first frame of the video.



:::if{props.platform=undefined}
<CodeGroup>
``` java SampleCode
// Receive rich media content in one-on-one chat - Receive images:
 @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        super.onReceivePeerMessage(zim, messageList, fromUserID);
        for (ZIMMessage message : messageList) {
            // You can tell by the Type which kind of message you are receiving. 
            if (message.getType() == ZIMMessageType.IMAGE) {
                // Receive images.
                ZIMImageMessage imageMessage = (ZIMImageMessage) message;
                zim.downloadMediaFile(imageMessage, ZIMMediaFileType.ORIGINAL_FILE, new ZIMMediaDownloadedCallback() {

                    @Override
                    public void onMediaDownloaded(ZIMMediaMessage message, ZIMError errorInfo) {
                        // Callback on the downloading completed.
                    }

                    @Override
                    public void onMediaDownloadingProgress(ZIMMediaMessage message, long currentFileSize, long totalFileSize) {
                        //  Callback on the downloading progress.
                    }
                });
            } else if (message.getType() == ZIMMessageType.VIDEO) {
                // Receive videos.
                ZIMVideoMessage videoMessage = (ZIMVideoMessage) message;
            } else if (message.getType() == ZIMMessageType.AUDIO) {
                // Receive audios.
                ZIMAudioMessage audioMessage = (ZIMAudioMessage) message;
            } else if (message.getType() == ZIMMessageType.FILE) {
                // Receive files.
                ZIMFileMessage fileMessage = (ZIMFileMessage) message;
            }
        }
    }
```

</CodeGroup>

:::
:::if{props.platform="mac"}
<CodeGroup>
```objc SampleCode
// Receive rich media content in one-on-one chat - Receive images 
- (void)receivePeerMessage:(NSArray<ZIMMessage *> *)messageList
                fromUserID:(NSString *)fromUserID{
    for (ZIMMessage *msg in reverseMsgList) {

        // You can tell by the Type which kind of message you are receiving. 
        switch (msg.type) {
            case ZIMMessageTypeImage:{
                ZIMImageMessage *imageMsg = (ZIMImageMessage *)msg;
                [[ZIM getInstance] downloadMediaFileWithMessage:imageMsg fileType:ZIMMediaFileTypeOriginalFile progress:^(ZIMMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
                            
                            } callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
                                
                }];
                break;
            }
            case ZIMMessageTypeVideo:{
                ZIMVideoMessage *videoMsg = (ZIMVideoMessage *)msg;
                break;
            }
            case ZIMMessageTypeAudio:{
                ZIMAudioMessage *audioMsg = (ZIMAudioMessage *)msg;
                break;
            }
            case ZIMMessageTypeFile:{
                ZIMFileMessage *fileMsg = (ZIMFileMessage *)msg;
                break;
            }
            default:
                break;
        }
        
    }
}
```
</CodeGroup>
:::
:::if{props.platform="iOS"}
<CodeGroup>
```objc SampleCode
// Receive rich media content in one-on-one chat - Receive images 
- (void)receivePeerMessage:(NSArray<ZIMMessage *> *)messageList
                fromUserID:(NSString *)fromUserID{
    for (ZIMMessage *msg in reverseMsgList) {

        // You can tell by the Type which kind of message you are receiving. 
        switch (msg.type) {
            case ZIMMessageTypeImage:{
                ZIMImageMessage *imageMsg = (ZIMImageMessage *)msg;
                [[ZIM getInstance] downloadMediaFileWithMessage:imageMsg fileType:ZIMMediaFileTypeOriginalFile progress:^(ZIMMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
                            
                            } callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
                                
                }];
                break;
            }
            case ZIMMessageTypeVideo:{
                ZIMVideoMessage *videoMsg = (ZIMVideoMessage *)msg;
                break;
            }
            case ZIMMessageTypeAudio:{
                ZIMAudioMessage *audioMsg = (ZIMAudioMessage *)msg;
                break;
            }
            case ZIMMessageTypeFile:{
                ZIMFileMessage *fileMsg = (ZIMFileMessage *)msg;
                break;
            }
            default:
                break;
        }
        
    }
}
```
</CodeGroup>
:::




#### Callback for the downloading progress of rich media content


You will be notified of the downloading progress of rich media content through the callback {getPlatformData(props,onMediaDownloadingProgressMap)}.


Among which:

- message: The message content you are downloading.
- currentFileSize: The size of messages that have been downloaded.
- totalFileSize: The overall size of the download message.


## Send/Receive signaling messages


The ZIM SDK now supports you to send and receive signaling messages. To do that, you can call the {getPlatformData(props,ZIMCommandMessageMap)} to define the message type you want to send, for example, your location information.

<Note title="Note">

This message type does not support offline push and local storage.
</Note>

The following shows how to send custom messages to a specified user.

### Send signaling messages



:::if{props.platform=undefined}
<CodeGroup>
```java SampleCode


// Send signaling messages to a specified user.

// 1. Create a ZIM object and pass in appID, appSign and Application in Android
// For specific codes, please refer to the related codes of the above [Send & Receive messages - Send Messages].

// 2. Set setEventHandler callback
// For specific codes, please refer to the related codes of the above [Send & Receive messages - Send Messages].

// 3. Log in
// For specific codes, please refer to the related codes of the above [Send & Receive messages - Send Messages].

// 4. Send signaling messages.
String userID = "xxxx";

ZIMCommandMessage zimCustomMessage = new ZIMCommandMessage();
zimCustomMessage.message = new byte[]{0x1,0x2,0x1,0x2};

ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// Set message priority.
config.priority = ZIMMessagePriority.LOW;
// For a room chat, offline notification is not supported. To use it, contact ZEGOCLOUD Technical Support to enable the feature first.

// Send one-on-one messages.
ZIMConversationType type = ZIMConversationType.Peer;

// Send group messages.
ZIMConversationType type = ZIMConversationType.Gourp;

// Send in-room messages.
ZIMConversationType type = ZIMConversationType.Room;

zim.sendMessage(zimCustomMessage, toConversationID, type,config, new ZIMMessageSentCallback() {
    @Override
    public void onMessageAttached(ZIMMessage zimMessage) {
        // You can use this callback to monitor whether the message is ready to be sent. This callback will be thrown only if the message passes the local basic parameter verification, otherwise an error will be thrown through the onMessageSent callback.
    }

    @Override
    public void onMessageSent(ZIMMessage zimMessage, ZIMError error) {
        // You can listen for the callback to know whether the message is sent successfully.
    }
});
```
</CodeGroup>
:::
:::if{props.platform="mac"}
<CodeGroup>
```objc SampleCode
// Send signaling messages to a specified user.
NSData *anyData = [[NSData alloc] init];
NSString *toUserID = @"toUserID";
ZIMCommandMessage * cmdMsg = [[ZIMCommandMessage alloc] initWithMessage:anyData];
ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = ZIMMessagePriorityMedium;

[self.zim sendMessage:cmdMsg toUserID:toUserID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // You can listen for this callback on the results of the message sending.
}];
```
</CodeGroup>
:::
:::if{props.platform="iOS"}
<CodeGroup>
```objc SampleCode
// Send signaling messages to a specified user.
NSData *anyData = [[NSData alloc] init];
NSString *toUserID = @"toUserID";
ZIMCommandMessage * cmdMsg = [[ZIMCommandMessage alloc] initWithMessage:anyData];
ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = ZIMMessagePriorityMedium;

[self.zim sendMessage:cmdMsg toUserID:toUserID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // You can listen for this callback on the results of the message sending.
}];
```
</CodeGroup>
:::



### Receive signaling messages



:::if{props.platform=undefined}
<CodeGroup>
```java SampleCode
// Receive signaling messages.
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        // Callback on the custom message received.
        for (ZIMMessage zimMessage : messageList) {
            if (zimMessage instanceof ZIMCommandMessage) {
                ZIMCommandMessage zimCommandMessage = (ZIMCommandMessage) zimMessage;
                
           }    
        }
    }
});
```
</CodeGroup>
:::
:::if{props.platform="mac"}
<CodeGroup>
```objc SampleCode
// Receive signaling messages.
- (void)zim:(ZIM *)zim receivePeerMessage:(NSArray<ZIMMessage *> *)messageList fromUserID:(NSString *)fromUserID {
    if (zim != self.zim) {
        return;
    }
    for (ZIMMessage *msg in messageList) {
        if(msg.type == ZIMMessageTypeCommand){
            ZIMCommandMessage *cmdMsg = (ZIMCommandMessage *)msg;
            NSData *receivedData = cmdMsg.message;
        }
    }
}
```
</CodeGroup>
:::
:::if{props.platform="iOS"}
<CodeGroup>
```objc SampleCode
// Receive signaling messages.
- (void)zim:(ZIM *)zim receivePeerMessage:(NSArray<ZIMMessage *> *)messageList fromUserID:(NSString *)fromUserID {
    if (zim != self.zim) {
        return;
    }
    for (ZIMMessage *msg in messageList) {
        if(msg.type == ZIMMessageTypeCommand){
            ZIMCommandMessage *cmdMsg = (ZIMCommandMessage *)msg;
            NSData *receivedData = cmdMsg.message;
        }
    }
}
```
</CodeGroup>
:::


## Send and receive custom message

The ZIM SDK supports developers in implementing the sending and receiving of custom message types. Developers can define their own message types using the {getPlatformData(props,ZIMCustomMessageMap)}  object, such as voting, chain, video card, and more. Developers can follow these steps to implement the sending and receiving of custom messages.
<Note title="Note">

- Only ZIM SDK version 2.8.0 and above supports sending custom type messages, receiving and viewing the content of custom type messages.
- If the SDK version of the receiving end is between [2.0.0, 2.8.0), the custom message can be received, but the message type will be displayed as unknown and the information content cannot be obtained. To get this message, please upgrade the SDK to version 2.8.0 or above.
- If the SDK version of the receiving end is version 1.x.x, you cannot receive custom messages or unknown messages.
</Note>

### Send custom messages

The interface used to send custom messages is {getPlatformData(props,sendMessageMap)}, which is the same as the interface used to send regular messages. Developers can refer to [Send & Receive messages - Send messages](#send-rich-media-content) to learn about this interface Parameter details.

Developers need to define custom type messages through the {getPlatformData(props,ZIMCustomMessageMap)} object.

:::if{props.platform=undefined}
```java
// Send a custom message to specified users in a one-to-one chat
// 1. Create a ZIM object and pass in appID, appSign and Application in Android
// For specific codes, please refer to the related codes of the above [Send & Receive messages - Send Messages].

// 2. Set setEventHandler callback
// For specific codes, please refer to the related codes of the above [Send & Receive messages - Send Messages].

// 3. Log in
// For specific codes, please refer to the related codes of the above [Send & Receive messages - Send Messages].

// 4. Send custom informatio
// Specify the user's ID
String userID = "xxxx";

// Customize the text content of the message
String message = "";

// Specific custom type
int subType = 100; 

// Customize the search field of the message.
String searchedContent = "";

ZIMCustomMessage zimCustomMessage = new ZIMCustomMessage(message,subType);

// Advanced property configuration for sending messages
ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// Set message priority
config.priority = ZIMMessagePriority.LOW;

// Send one-to-one chat message 
// ZIMConversationType type = ZIMConversationType.Peer;

// Send group chat message
// ZIMConversationType type = ZIMConversationType.Gourp;

// Send room message
// ZIMConversationType type = ZIMConversationType.Room;

zim.sendMessage(zimCustomMessage, toConversationID, type,config, new ZIMMessageSentCallback() {
    @Override
    public void onMessageAttached(ZIMMessage zimMessage) {
        // You can use this callback to monitor whether the message is ready to be sent. This callback will be thrown only if the message passes the local basic parameter verification, otherwise an error will be thrown through the onMessageSent callback.            
    }

    @Override
    public void onMessageSent(ZIMMessage zimMessage, ZIMError error) {
        // You can use this callback to monitor whether the message is sent successfully.
    }
});
```

:::
:::if{props.platform="mac"}
```objc
 // Send a custom message to the specified user.
 NSString *message = @"message";
 NSString *toUserID = @"toUserID";
 ZIMCustomMessage * customMessage = [[ZIMCustomMessage alloc] init];
 customMessage.message = message;
 customMessage.subType = 1; // Developer-defined type
 customMessage.searchContent="";
 ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
 sendConfig.priority = ZIMMessagePriorityMedium;

 [self.zim sendMessage:customMessage toUserID:toUserID conversationType: ZIMConversationTypePeer config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
     // Developers can use this callback to monitor whether the message is sent successfully.
 }];
 ```
:::
:::if{props.platform="iOS"}
```objc
 // Send a custom message to the specified user.
 NSString *message = @"message";
 NSString *toUserID = @"toUserID";
 ZIMCustomMessage * customMessage = [[ZIMCustomMessage alloc] init];
 customMessage.message = message;
 customMessage.subType = 1; // Developer-defined type
 customMessage.searchContent="";
 ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
 sendConfig.priority = ZIMMessagePriorityMedium;

 [self.zim sendMessage:customMessage toUserID:toUserID conversationType: ZIMConversationTypePeer config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
     // Developers can use this callback to monitor whether the message is sent successfully.
 }];
 ```
:::



### Receive custom messages

The callback interface for receiving custom messages is the same as the callback interface for receiving regular messages. Please refer to [Send & Receive messages - Receive messages](#receive-rich-media-content) for details on the specific interface.

The following is an example code for receiving custom messages in a one-on-one chat session:

:::if{props.platform=undefined}
```java
// User receives custom message in a one-to-one chat
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        // Callback when receiving "one-to-one chat" message
        for (ZIMMessage zimMessage : messageList) {
            if (zimMessage instanceof ZIMCustomMessage) {
                ZIMCustomMessage zimCustomMessage = (ZIMCustomMessage) zimMessage;
                
           }    
        }
    }
});
```

:::
:::if{props.platform="mac"}
```objc
 // Receiving custom messages in a one-on-one chat session
 - (void)zim:(ZIM *)zim receivePeerMessage:(NSArray<ZIMMessage *> *)messageList fromUserID:(NSString *)fromUserID {
     if (zim != self.zim) {
         return;
    }
    for (ZIMMessage *msg in messageList) {
        if(msg.type == ZIMCustomMessage){
            // This indicates that a custom message has been received.
         }
    }
 }
 ```
:::
:::if{props.platform="iOS"}
```objc
 // Receiving custom messages in a one-on-one chat session
 - (void)zim:(ZIM *)zim receivePeerMessage:(NSArray<ZIMMessage *> *)messageList fromUserID:(NSString *)fromUserID {
     if (zim != self.zim) {
         return;
    }
    for (ZIMMessage *msg in messageList) {
        if(msg.type == ZIMCustomMessage){
            // This indicates that a custom message has been received.
         }
    }
 }
 ```
:::


## Send and Receive @ Messages

An "@" message refers to a message that contains the content of "@ + user". When a user is mentioned with an "@" message, they receive a strong notification.

<Note title="Note">

The "@" message is not a message type itself. A message can be both a text message or another type of message, and it can also be an "@" message.
</Note>

### Send @ messages

When calling {getPlatformData(props,sendMessageMap)} to send a message, you can use the following {getPlatformData(props,ZIMMessageMap)}  parameters (can be used simultaneously) to mark a message as an "@" message:
- {getPlatformData(props,setMentionedUserIDsMap)}: Notifies specific users (including users outside of the session) to view the message. The length of the userID list passed in should be up to 50. If you need to increase this limit, please contact the ZEGOCLOUD technical support team.
- {getPlatformData(props,isMentionAllMap)}: Notifies all other users within the session to view the message.

<Note title="Note">

Only ZIM SDK version 2.14.0 and above supports sending messages with @ information.

</Note>

:::if{props.platform=undefined}
```java
// The following is a sample code for a user to send an @ message in a single chat session:

// Create reminder user list
ArrayList<String> mentionArrayList = new ArrayList<>();

// Add a reminder to the user (the user does not need to be in the current session)
mentionArrayList.add("userId1");
mentionArrayList.add("userId2");

// message can be any type of message
// Call the interface to remind users in the list to view messages
message.setMentionedUserIDs(mentionArrayList);

// Remind all other users in the session to view the message
boolean isMentionAll = true;
message.setIsMentionAll(isMentionAll);

ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// Set message priority
config.priority = ZIMMessagePriority.LOW;

// Whether to forcefully push the notification to the alerted user (regardless of whether the other party has enabled Do Not Disturb mode), the default is fasle;
config.isNotifyMentionedUsers = true;

// Take sending a one-to-one chat message as an example
ZIMConversationType type = ZIMConversationType.Peer;

zim.sendMessage(message,"conv_id", type, config, new ZIMMessageSentCallback() {
    @Override
    public void onMessageAttached(ZIMMessage zimMessage) {
        // You can use this callback to monitor whether the message is ready to be sent. This callback will be thrown only if the message passes the local basic parameter verification, otherwise an error will be thrown through the onMessageSent callback.           
    }

  @Override
    public void onMessageSent(ZIMMessage zimMessage, ZIMError error) {
         // Developers can use this callback to monitor whether the message is sent successfully.
    }
}];

```

:::
:::if{props.platform="mac"}
```objc
// The following is a sample code for a user to send an @ message in a single chat session:
// Create a reminder user list
NSMutableArray<NSString *> *mentionArrayList = [[NSMutableArray alloc] init];

// Add a reminder to the user (the user does not need to be in the current session)
[mentionArrayList addObject:@"userId1"];
[mentionArrayList addObject:@"userId2"];

// message can be any type of message
// Call the interface to remind users in the list to view messages
[message mentionedUserIDs:mentionArrayList];

// Remind all other users in the session to view the message
BOOL isMentionAll = YES;
[message isMentionAll:isMentionAll];

ZIMMessageSendConfig *config = [[ZIMMessageSendConfig alloc] init];
// Whether to forcefully push the notification to the alerted user (regardless of whether the other party has enabled Do Not Disturb mode), the default is NO;
config.isNotifyMentionedUsers = YES;

// Take sending one-to-one chat messages as an example
ZIMConversationType type = ZIMConversationTypePeer;

[zim sendMessage:message convId:@"conv_id" type:type config:config callback:^(ZIMMessage *zimMessage, ZIMError *error) {
  if (error) {
        // Developers can use this callback to monitor whether the message is sent successfully.
    }
}];

```

:::
:::if{props.platform="iOS"}
```objc
// The following is a sample code for a user to send an @ message in a single chat session:
// Create a reminder user list
NSMutableArray<NSString *> *mentionArrayList = [[NSMutableArray alloc] init];

// Add a reminder to the user (the user does not need to be in the current session)
[mentionArrayList addObject:@"userId1"];
[mentionArrayList addObject:@"userId2"];

// message can be any type of message
// Call the interface to remind users in the list to view messages
[message mentionedUserIDs:mentionArrayList];

// Remind all other users in the session to view the message
BOOL isMentionAll = YES;
[message isMentionAll:isMentionAll];

ZIMMessageSendConfig *config = [[ZIMMessageSendConfig alloc] init];
// Whether to forcefully push the notification to the alerted user (regardless of whether the other party has enabled Do Not Disturb mode), the default is NO;
config.isNotifyMentionedUsers = YES;

// Take sending one-to-one chat messages as an example
ZIMConversationType type = ZIMConversationTypePeer;

[zim sendMessage:message convId:@"conv_id" type:type config:config callback:^(ZIMMessage *zimMessage, ZIMError *error) {
  if (error) {
        // Developers can use this callback to monitor whether the message is sent successfully.
    }
}];

```

:::


### Receive @ messages

The callback interface for receiving @ messages is the same as the callback interface for receiving regular messages. Please refer to [Send & Receive messages - Receive messages](#receive-rich-media-content) for details on the specific interface.

After receiving a message, developers can implement corresponding functionalities based on their business logic, such as highlighting, etc.

<Note title="Note">

- Only ZIM SDK versions 2.14.0 and above support receiving and viewing the content of @ messages.
- If the SDK version on the receiving end is between [2.0.0, 2.14.0), the received messages and conversations will not contain @ information.
- If the SDK version on the receiving end is version 1.x.x, @ messages cannot be received.
</Note>

### Receive mentionedInfoList

After users within a session are mentioned, developers can passively or actively retrieve {getPlatformData(props,mentionedInfoListMap)}.

{getPlatformData(props,mentionedInfoListMap)} contains the corresponding message ID, sender userID, and the type of {getPlatformData(props,ZIMMessageMentionedTypeMap)}.Developers can use this information to implement various business logics, such as marking conversations.

#### Passive retrieval

When a user is mentioned, the {getPlatformData(props,onConversationChangedMap)} will be received, allowing you to retrieve the latest {getPlatformData(props,mentionedInfoListMap)}for the current {getPlatformData(props,ZIMConversationMap)}.

:::if{props.platform=undefined}
```java
@Override
  public void onConversationChanged(
      ZIM zim, ArrayList<ZIMConversationChangeInfo> conversationChangeInfoList) {
      // conversationChangeInfoList You can get the mentionInfoList in the conversation that received the reminder
  }
```

:::
:::if{props.platform="mac"}
```objc
 - (void)zim:(ZIM *)zim
     conversationChanged:(NSArray<ZIMConversationChangeInfo *> *)conversationChangeInfoList {
         // Retrieve mentionInfoList from the conversationChangeInfoList of the mentioned conversation
    }
```
:::
:::if{props.platform="iOS"}
```objc
 - (void)zim:(ZIM *)zim
     conversationChanged:(NSArray<ZIMConversationChangeInfo *> *)conversationChangeInfoList {
         // Retrieve mentionInfoList from the conversationChangeInfoList of the mentioned conversation
    }
```
:::


#### Active retrieval

If you use {getPlatformData(props,queryConversationListWithConfigMap)} or {getPlatformData(props,queryConversationMap)} o actively fetch conversations, you can also retrieve the {getPlatformData(props,mentionedInfoListMap)} within the conversation. Refer to the following example code:

:::if{props.platform=undefined}
```java
ArrayList<ZIMMessageMentionedInfo> mentionedInfoList = conversation.mentionedInfoList;
```

:::
:::if{props.platform="mac"}
```objc
 NSArray<ZIMMessageMentionedInfo *> * mentionedInfoList = conversation.mentionedInfoList;
 ```
:::
:::if{props.platform="iOS"}
```objc
 NSArray<ZIMMessageMentionedInfo *> * mentionedInfoList = conversation.mentionedInfoList;
 ```
:::

### Clearing mentionedInfoList of a conversation

After receiving @ messages, users need to clear the [mentionedInfoList](@mentionedInfoList) of a conversation to stop receiving notifications.

The interface for clearing the mentionedInfoList  is the same as clearing the unread message count of a conversation:
- {getPlatformData(props,clearConversationUnreadMessageCountMap)}: Clears the unread message count of a single conversation. Refer to the example code in [Manage sessions - Clear single session message unread](./../Conversation/Get%20the%20conversation%20list.mdx).
- {getPlatformData(props,clearConversationTotalUnreadMessageCountMap)}: Clears the total unread message count of all conversations. Refer to the example code in [Manage sessions - Clear all unread conversation messages](./../Conversation/Get%20the%20conversation%20list.mdx).

### Get reminder user list

All users in the session can call the `getMentionedUserIDs` interface. Get the specific reminder user list, but this interface can only return the user list passed in by calling the `setMentionedUserIDs` interface.

:::if{props.platform=undefined}
```java
ArrayList<String> userIds = message.getMentionedUserIDs();
```

:::
:::if{props.platform="mac"}
```objc
 NSArray<NSString *> *userIds = message.mentionedUserIDs;
```
:::
:::if{props.platform="iOS"}
```objc
 NSArray<NSString *> *userIds = message.mentionedUserIDs;
```
:::

### Confirm whether it is a reminder for all members

All users within the conversation can use the {getPlatformData(props,isMentionAllMap)} parameter of {getPlatformData(props,ZIMMessageMap)}to determine whether it is a reminder for all members. 

:::if{props.platform=undefined}
```java
boolean isMentionAll = message.isMentionAll();
```

:::
:::if{props.platform="mac"}
```objc
BOOL isMentionAll = message.isMentionAll;
```
:::
:::if{props.platform="iOS"}
```objc
BOOL isMentionAll = message.isMentionAll;
```
:::

## Send and receiving broadcast messages

ZIM allows you to send messages to all online users of your app from the server side, and the targeted users will receive the messages through the client side.

### Send messages to all users from the server side

Please refer to the server-side API documentation [Push message to all user](/zim-server/push-message-to-all-users) to learn how to send messages to all users from the server side.


### Receive broadcast messages sent from the server side

<Note title="Note">

- Only ZIM SDK versions 2.10.0 and above support receiving and viewing the content of broadcast messages sent from the server side.
- If the SDK version on the receiving end is between [2.0.0, 2.10.0), broadcast messages sent from the server side cannot be received. If you need to access this message, please upgrade the SDK to version 2.10.0 or above. 
</Note>

Through the {getPlatformData(props,onBroadcastMessageReceivedMap)} callback, you can receive push messages from all members.

Sample code:

:::if{props.platform=undefined}
```java
// User receives broadcast messages 
public void onBroadcastMessageReceived(ZIM zim, ZIMMessage message) {
  super.onBroadcastMessageReceived(zim, message);
    // Receive broadcast messages from all members
}
```

:::
:::if{props.platform="mac"}
```objc
 // User receives broadcast messages
 - (void)zim:(ZIM *)zim broadcastMessageReceived:(ZIMMessage *)message {
     // Receive broadcast messages from all members
 }
 ```
:::
:::if{props.platform="iOS"}
```objc
 // User receives broadcast messages
 - (void)zim:(ZIM *)zim broadcastMessageReceived:(ZIMMessage *)message {
     // Receive broadcast messages from all members
 }
 ```
:::

## Forward message

The ZIM SDK supports forwarding messages in one of the following ways: 

- Combining messages and forwarding the combined message. 
- Forwarding messages one by one.

For more information, see [Forward messages](./Forward%20messages.mdx).

## Receive Tips message

ZIM SDK supports converting user operations within a session into Tips messages. When a related operation occurs, ZIM SDK will send a Tips message to the session to notify. For details, please refer to [Receive tip messages](./Receive%20tip%20messages.mdx).




## Listen for the message status 

On a weak network condition, this may happen: the ZIM SDK doesn't receive the response from the server for some reason (e.g., packet loss), while the message is successfully sent. In this case, the ZIM SDK considers the message sending failed due to the reply timeout, but the message is actually sent successfully, which results in message status confusion.
To solve this and Clarify the message status, the SDK 2.6.0 or later now allows you to listen for the {getPlatformData(props,onMessageSentStatusChangedMap)} callback to receive the changes of the message status.
And we now have three different message statuses: Sending, Success, and Failed.
You can know whether your message is sent successfully by the status, and implement your event handling logic as needed.

:::if{props.platform=undefined}
```java
//  Listen for the message status 
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onMessageSentStatusChanged(
        ZIM zim, ArrayList<ZIMMessageSentStatusChangeInfo> messageSentStatusChangeInfoList) {
            // You can listen for the callback on the changes of message status here.
}
});
```

:::
:::if{props.platform="mac"}
```objc
//  Listen for the message status.
- (void)zim:(ZIM *)zim messageSentStatusChanged:
        (NSArray<ZIMMessageSentStatusChangeInfo *> *)messageSentStatusChangeInfoList {
            // You can listen for the callback on the changes of message status here.
}
```
:::
:::if{props.platform="iOS"}
```objc
//  Listen for the message status.
- (void)zim:(ZIM *)zim messageSentStatusChanged:
        (NSArray<ZIMMessageSentStatusChangeInfo *> *)messageSentStatusChangeInfoList {
            // You can listen for the callback on the changes of message status here.
}
```
:::

