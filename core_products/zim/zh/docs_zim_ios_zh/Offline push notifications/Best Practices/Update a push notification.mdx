import { getPlatformData } from '/snippets/utils-content-parser.js';


export const ZIMPushConfig={
    "Android": <a href="https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~class~ZIMPushConfig" target="_blank">ZIMPushConfig</a>,
    "RN": <a href="https://doc-zh.zego.im/article/api?doc=zim_API~javascript_react-native~interface~ZIMPushConfig" target="_blank">ZIMPushConfig</a>,
    "Flutter": <a href="https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMPushConfig-class.html" target="_blank">ZIMPushConfig</a>
}

# Update a push notification

:::if{props.platform="Flutter"}
<div>
<Note title="Note">
This feature is only available on iOS devices.
</Note>
</div>
:::
:::if{props.platform="RN"}
<div>
<Note title="Note">
This feature is only available on iOS devices.
</Note>
</div>
:::

## Overview

When sending a new notification, you can also retract the previous push notification. This feature is commonly used to cancel a call invitation, retract a message, and other scenarios.

## How it works

ZPNs supports including the `"mutable-content":1` field when sending APNs push notifications. This allows your app to intercept the push message, modify its content, and then display it. For more details, please refer to [Description of Mutable-content](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification#2943360) in the Official Documentation of Apple Developer.

## Configure resourceID

Contact ZEGO technical support to configure the resourceID that carries `"mutable-content":1`.

## Sender

When sending offline push notifications with {getPlatformData(props, ZIMPushConfig)}, please fill in the above `resourceID`.

Taking sending a call invitation as an example:

:::if{props.platform=undefined}
```objc
ZIMCallInviteConfig *config = [[ZIMCallInviteConfig alloc] init];
config.timeout = 60;
config.mode = ZIMCallInvitationModeGeneral;
ZIMPushConfig *pushConfig = [[ZIMPushConfig alloc] init];
pushConfig.resourcesID = KeyCenter.resourceID;
pushConfig.title = [ZGZIMManager shared].myUserID;
pushConfig.content = @"Invite you to voice call";

// payload carries a custom identifier
pushConfig.payload =  @"{\"customId\":\"1\"}";
config.pushConfig = pushConfig;
// Send a call invitation
[[ZGZIMManager shared] callInviteWithInvitees:self.selectMemberList config:config callback:^(NSString * _Nonnull callID, ZIMCallInvitationSentInfo * _Nonnull info, ZIMError * _Nonnull errorInfo) {}];
```
:::
:::if{props.platform="Flutter"}
```dart
ZIMCallInviteConfig config = ZIMCallInviteConfig();
config.timeout = 60;
config.mode = ZIMCallInvitationMode.general;
ZIMPushConfig pushConfig = ZIMPushConfig();
pushConfig.resourcesID = "resourceID which carries mutable-content";
// payload carries a custom identifier
pushConfig.payload =  "{\"customId\":\"1\"}";
ZIM.getInstance()?.callInvite(["userID1","userID2"], config);
```
:::
:::if{props.platform="RN"}
```javascript
var invitees = ['xxxx'];  // List of invitee IDs
var config = { 
    timeout: 60 ,// Invitation timeout in seconds, ranging from 1 to 600   
    pushConfig:{
        title: 'push title',
        content: 'push content',
        payload: '{\"customId\":\"1\"}',// Payload carrying a custom unique identifier
        resourcesID: "resourceID carrying mutable-content"
}}; 
zim.callInvite(invitees, config)
    .then(function({ callID, timeout, errorInvitees }){
        // Operation succeeded
        // The callID here is the ID generated by the SDK to uniquely identify a call invitation after the user initiates a call; this callID will be used when the initiator cancels the call or the invitee accepts/rejects the call
    })
    .catch(function(err){
        // Operation failed
    })
```
:::

## Receiver

<Steps>
<Step title="Configure Capability">
Open Xcode, select the target under TARGETS, and go to Signing & Capabilities > Capabilities. Enable **Push Notification** (for offline push notifications).
</Step>
<Step title="Set up Notification Service Extension">
<Steps>
<Step title="Add Notification Service Extension to Targets">
    1. Click "File > New > Target..."

        <Frame width="512" height="auto" caption=""><img src="https://storage.zego.im/sdk-doc/Pics/ZIM/ZPNS/pic_5.jpeg" /></Frame>

    2. In the pop-up window, select "iOS > Notification Service Extension".
    
        <Frame width="512" height="auto" caption=""><img src="https://storage.zego.im/sdk-doc/Pics/ZIM/ZPNS/pic_6.jpeg" /></Frame>

    3. Enter the Product Name and other information for the extension.

        <Frame width="512" height="auto" caption=""><img src="https://storage.zego.im/sdk-doc/Pics/ZIM/ZPNS/pic_7.jpeg" /></Frame>

    After creating the extension, a "xxxExtension" folder (xxx is the Product Name entered when adding the extension) will be generated in the project. You will use the NotificationService class file in it.

</Step>
<Step title="Configure Capability for the newly added extension">
    Select the extension target under TARGETS, and then go to "Signing & Capabilities > Capabilities > Push Notification" to enable offline push notifications.

    <Frame width="512" height="auto" caption=""><img src="https://storage.zego.im/sdk-doc/Pics/ZIM/ZPNS/pic_9.jpeg" /></Frame>
</Step>
<Step title="Adjust the minimum supported version of the newly added extension to iOS 11.0 or above">
    If the iOS version of the used device is lower than the version specified here, the extension will not take effect on that device.

    <Frame width="512" height="auto" caption=""><img src="https://storage.zego.im/sdk-doc/Pics/ZIM/ZPNS/pic_10.jpeg" /></Frame>
</Step>
</Steps>
</Step>
<Step title="Write the logic to replace the notification">
In the NotificationService.m file in the "xxxExtension" folder (xxx is the Product Name entered when adding the extension), write the business logic to update the notification. The example code is as follows:

```objc
//  NotificationService.m
//  NotificationService

#import "NotificationService.h"
#import <Intents/Intents.h>

@interface NotificationService ()

@property (nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);
@property (nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;

@end

@implementation NotificationService


// When push interception is enabled, this method will be triggered when a push notification with "mutable-content":1 is received.
- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler {
    self.contentHandler = contentHandler;
    self.bestAttemptContent = [request.content mutableCopy];
    // Title
    NSString *title = self.bestAttemptContent.title;
    // Subtitle
    NSString *subtitle = self.bestAttemptContent.subtitle;
    // Body
    NSString *body = self.bestAttemptContent.body;

    // Get the payload string carried by the push message
    NSString *payload = [self.bestAttemptContent.userInfo objectForKey:@"payload"];

    if(payload == nil){
        self.contentHandler(self.bestAttemptContent);
        return;
    }
    
    
    // Parse the JSON string and convert it to NSDictionary
    NSData *jsonData = [payload dataUsingEncoding:NSUTF8StringEncoding];
    NSError *error = nil;
    NSDictionary *payload_json_map = [NSJSONSerialization JSONObjectWithData:jsonData options:kNilOptions error:&error];
    if (error) {
        self.contentHandler(self.bestAttemptContent);
        return;
    }
    
    // Extract the unique identifier carried by the payload
    NSString *customId = [payload_json_map objectForKey:@"customId"];

    if(customId != nil){
        [UNUserNotificationCenter.currentNotificationCenter getDeliveredNotificationsWithCompletionHandler:^(NSArray<UNNotification *> * _Nonnull notifications) {
            NSString *target_id = nil;

            // Traverse the existing notifications, find the notification with the same unique identifier, and delete it
            for (int index = 0; index < notifications.count; index ++) {
                if([[notifications[index].request.content.userInfo objectForKey:@"customId"] isEqual: customId]){
                    target_id = notifications[index].request.identifier;
                    break;
                }
            }
            if(target_id != nil){
                [UNUserNotificationCenter.currentNotificationCenter removeDeliveredNotificationsWithIdentifiers:@[target_id]];
            }
            contentHandler(self.bestAttemptContent);
        }];
    }else{
        contentHandler(self.bestAttemptContent);
    }
    
}

@end
```
</Step>
</Steps>
